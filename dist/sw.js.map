{"version":3,"sources":["sw.js"],"names":["s","ORIGIN","STATIC_CACHE","DYNAMIC_CACHE","RESOURCES_TO_CACHE","addEventListener","sendMessageToClients","message","clients","matchAll","then","forEach","client","postMessage","action","catch","error","console","log","event","waitUntil","caches","open","keys","cacheName","cacheNames","Promise","all","filter","startsWith","map","request","respondWith","claim","response","url","location","origin","indexOf","search","match","cache","fetch","skipWaiting","clone","data","self"],"mappings":"cAAA,SAAEA,GAAF,IACAC,EAAA,UAGEC,EAAkBD,EAAlB,kBAFFE,EAAAF,EAAA,mBAAAG,EACW,CADX,IAAA,cAAA,mBAeI,kBACA,aANA,cASJ,0BAPI,+BACA,YASFC,gBAIM,gBAiHR,SAASC,EAAqBC,GAE5BP,EAAEQ,QAAQC,WACPC,KAAK,SAAAF,GACJA,EAAQG,QAAQ,SAAAC,GACdA,EAAOC,YAAY,CAACC,OAAQP,QAG/BQ,MAAM,SAAAC,GACLC,QAAQC,IAAI,gEAAiEF,KAlHnFhB,EAAAK,iBAAA,UAAA,SAAAc,GAXEA,EAAMC,UACJC,OAAOC,KAAKpB,GAadG,KAAAA,SAAAA,GACAc,OAAMC,EACJC,OAAOE,KAICR,MAAA,SAAAC,GACAC,QAAQO,IAAAA,mCAAgCA,QAW5CP,EAAAA,iBAAY,WAAA,SAAAE,GACbA,EAlBLC,UADFC,OAAAE,OAGOb,KAAK,SAAAe,GAoBZ,OAAAC,QAAAC,IAlBUF,EAAWG,OAAO,SAAAJ,GAqB1BnB,OAAFmB,EAA4BK,WAAA5B,IAASuB,IAAAtB,GAAAsB,IAAArB,IACnC2B,IAAA,SAAAN,GACIL,OAAMY,OAAYF,OAAAA,QAMhBnB,KAAA,WAEFS,OAAMa,EAAAA,QAANC,UAIAd,MAAAA,SAAAA,GAGMF,QAAIiB,IAAAA,iCAAUlB,QAWFC,EAAAA,iBAAAA,QAAY,SAAAE,GAEhB,GAAAA,EAAAY,QAAAI,IAAOD,WAAPlC,EAAAoC,SAAAC,QACD,IACe,EADflB,EAXIY,QAYEI,IAAAG,QAAA,mBAAS,CACdrB,IAAY,IAAZA,EAAAA,QAAQC,IAAIqB,OAAA,QAKhBtB,YAJIE,EAAAa,YACDX,OAfHmB,MAAA,cAoBLrB,EACAJ,YACCE,OAAAA,MAAA,0BAITE,EAAAa,YA9CHX,OAAAmB,MAAArB,EAAAY,SAgBWrB,KAAK,SAAAwB,GAiChB,OAAAA,GA/BmBb,OAAOC,KAAKnB,GAChBO,KAAK,SAAA+B,GAiClBpC,OAAiBqC,MAAAvB,EAAWY,SACbjB,KAAAA,SAAAA,GACPM,OACY,MAAduB,EAAAA,OACYtB,OAAAmB,MAAA,cAEVlC,EAAAA,IAAqBa,EAAAY,QAArBG,EAAAU,SAEK7B,MAAA,SAAAC,GANXC,QAAAC,IAAA,qCAAAF,EAAAG,EAAAY,QAAAI,OAWED,KAEAnB,MAAA,SAAAC,GAGH,OAFGV,QAAqBY,IAAA,mCAFvBF,GAIDK,OAAAmB,MAAA,qBAGHzB,MAAA,SAAAC,GAnCgBC,QAAQC,IAAI,2CAA4CF,OAuCtED,MAAA,SAAAC,GACER,QAAQC,IAAV,wDACmBO,QA3BrBhB,EAAEK,iBAAiB,UAAW,SAASc,GACX,YAAtBA,EAAM0B,KAAK/B,QACbK,EAAMC,UACJpB,EAAE2C,cACCjC,KAAK,WAEJJ,EAAqB,eAEtBS,MAAM,SAAAC,GACLC,QAAQC,IAAI,mDAAoDF,MAI9C,YAAtBG,EAAM0B,KAAK/B,QACbK,EAAMC,UAEJd,EAAqB,gBArI3B,CAyJGwC","file":"sw.js","sourcesContent":["((s) => {\n'use strict';\nconst SW_VERSION = 1,\n  ORIGIN = 'NYC-RR-',\n  STATIC_CACHE = `${ORIGIN}static-cache-v${SW_VERSION}`,\n  DYNAMIC_CACHE = `${ORIGIN}dynamic-cache-v${SW_VERSION}`,\n  RESOURCES_TO_CACHE = [\n    '/',\n    '/index.html',\n    '/restaurant.html',\n    '/css/styles.css',\n    '/js/app.js',\n    '/js/main.js',\n    '/img/image-fallback.svg',\n    '/js/intersection-observer.js',\n    '/404.html',\n    '/offline.html',\n    /* Unfortunally Service Worker 'fetch' event does not trigger for favicons in Chrome. This bug is still open. https://bugs.chromium.org/p/chromium/issues/detail?id=448427 */\n    '/favicon.ico'\n];\n\n/**\n * Cache the main assets while installing SW.\n */\ns.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(STATIC_CACHE)\n      .then(cache => {\n        return cache.addAll(RESOURCES_TO_CACHE);\n      })\n      .catch(error => {\n        console.log('[SW] Installation failed, error:', error);\n      })\n  );\n});\n\n/**\n * Remove outdated caches while a new SW is activating.\n */\ns.addEventListener('activate', event => {\n  event.waitUntil(\n    caches.keys()\n      .then(cacheNames => {\n        return Promise.all(\n          cacheNames.filter(cacheName => {\n            // Caches are shared across the whole origin.\n            return (cacheName.startsWith(ORIGIN) && cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE);\n          }).map(cacheName => {\n            return caches.delete(cacheName);\n          })\n        );\n      })\n      .then(() => {\n        /* Allow the active service worker to set itself as the controller for all clients within its scope. This triggers a \"controllerchange\" event on navigator.serviceWorker in any clients that become controlled by this service worker. https://developer.mozilla.org/en-US/docs/Web/API/Clients/claim */\n        return s.clients.claim();\n      })\n      .catch(error => {\n        console.log('[SW] Activation failed, error:', error);\n      })\n  );\n});\n\n/**\n * Cache other resources dynamically with a fallback to the network.\n */\ns.addEventListener('fetch', event => {\n  /* The fetch handler serves responses only for same-origin resources. */\n  if (event.request.url.startsWith(s.location.origin)) {\n    if (event.request.url.indexOf('restaurant.html') > -1) {\n      if (event.request.url.search(/id=./) === -1) {\n        event.respondWith(\n          caches.match('/404.html')\n        );\n        return;\n      }\n      event.respondWith(\n        caches.match('/restaurant.html')\n      );\n    } else {\n      event.respondWith(\n        caches.match(event.request)\n          .then(response => {\n            if (response) return response;\n            return caches.open(DYNAMIC_CACHE)\n              .then(cache => {\n                return fetch(event.request)\n                  .then(response => {\n                    if (response.status === 404) {\n                      return caches.match('/404.html');\n                    }\n                    cache.put(event.request, response.clone())\n                      .catch(error => {\n                        /* In some cases dynamic caching fails: e.g. it's not possible to cache a resource because a \"DOMException: Quota exceeded\" error fires. */\n                        console.log('[SW] Dynamic caching failed, error', error, event.request.url);\n                      });\n                    return response;\n                  })\n                  .catch(error => {\n                    console.log('[SW] Fetch request failed, error', error);\n                    return caches.match('/offline.html');\n                  });\n              })\n              .catch(error => {\n                console.log('[SW] Opening dynamic cache failed, error', error);\n              });\n          })\n          .catch(error => {\n            console.log('[SW] Something failed while matching a request, error', error);\n          })\n      );\n    }\n  }\n});\n\n/**\n * Listen messages from client.\n */\ns.addEventListener('message', function(event) {\n  if (event.data.action === 'refresh') {\n    event.waitUntil(\n      s.skipWaiting() // Activate a new SW that is waiting.\n        .then(() => {\n          /* After receiving a message from one client, the new SW turns the message to all clients. */\n          sendMessageToClients('refreshed');\n        })\n        .catch(error => {\n          console.log('[SW] Something failed while skipping wait, error', error);\n        })\n    );\n  }\n  if (event.data.action === 'dismiss') {\n    event.waitUntil(\n      /* After receiving a message from one client, the current SW turns the message to all clients. */\n      sendMessageToClients('dismissed')\n    );\n  }\n});\n\n/**\n * Send a message to all clients.\n */\nfunction sendMessageToClients(message) {\n  /* Get a list of SW Client objects, and send a message to everyone. */\n  s.clients.matchAll()\n    .then(clients => {\n      clients.forEach(client => {\n        client.postMessage({action: message});\n      });\n    })\n    .catch(error => {\n      console.log('[SW] Something failed while sending message to clients, error', error);\n    });\n}\n})(self);\n"]}