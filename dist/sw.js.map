{"version":3,"sources":["sw.js"],"names":["s","ORIGIN","STATIC_CACHE","DYNAMIC_CACHE","RESOURCES_TO_CACHE","addEventListener","sendMessageToClients","message","clients","matchAll","then","forEach","client","postMessage","action","catch","error","console","log","event","waitUntil","caches","open","cache","addAll","Promise","keys","cacheNames","all","filter","cacheName","startsWith","delete","claim","respondWith","request","url","location","origin","response","search","match","fetch","status","skipWaiting","put","clone","data","self"],"mappings":"cAAA,SAAEA,GAAF,IACAC,EAAA,UAGEC,EAAkBD,EAAlB,kBAFFE,EAAAF,EAAA,mBAAAG,EACW,CADX,IAAA,cAAA,mBAeI,kBAfJ,aAUI,cAQJ,0BANI,+BACA,YAQFC,iBAqHF,SAASC,EAAqBC,GAE5BP,EAAEQ,QAAQC,WACPC,KAAK,SAAAF,GACJA,EAAQG,QAAQ,SAAAC,GACdA,EAAOC,YAAY,CAACC,OAAQP,QAG/BQ,MAAM,SAAAC,GACLC,QAAQC,IAAI,gEAAiEF,KA9HnFhB,EAAEK,iBAAiB,UAAW,SAAAc,GAY9BA,EAAAC,UAVIC,OAAOC,KAAKpB,GACTQ,KAAK,SAAAa,GAYVlB,OAAAA,EAAiBmB,OAAApB,KAIXW,MAAOU,SAAAA,GAEHR,QAAAC,IAAA,mCAAAF,QAULhB,EAAAK,iBACM,WAAS,SAAAc,GACdF,EAAAA,UACDI,OAlBLK,OADFhB,KAAA,SAAAiB,GAIQ,OAAOF,QAAQG,IAmBvBD,EAAAE,OAAA,SAAAC,GAhBY,OAAQA,EAAUC,WAAW9B,IAAW6B,IAAc5B,GAAgB4B,IAAc3B,IAmB9FE,IAAAA,SAAAA,GACA,OAAAgB,OAAAW,OAAAF,QAIMX,KAAAA,WAID,OAAAnB,EAAAQ,QAAAyB,UANHlB,MAUO,SAAAC,GACLG,QAAMe,IAAAA,iCAEDxB,QAWaV,EAAAK,iBAAA,QAAA,SAAAc,GAED,GAAAA,EAAAgB,QAJHC,IAAAL,WAAA/B,EAAAqC,SAAAC,QAKA,IAAA,EAAAnB,EAAAgB,QAAOI,IAAAA,QAAP,mBAAA,CACD,IACe,IADfpB,EACAJ,QAAMqB,IAAAI,OAAA,QAIV,YAHKvB,EAAAA,YACAI,OAAAoB,MAAOpB,cAKZF,EArBHe,YAsBDb,OACAN,MAAM,0BAIZI,EAAAe,YACFb,OAAAoB,MAAAtB,EAAAgB,SA9CHzB,KAAA,SAAA6B,GAiBY,OAAIA,GAgChBlB,OAAAC,KAAAnB,GA9BeO,KAAK,SAAAa,GACJ,OAAOmB,MAAMvB,EAAMgB,SAgCjC9B,KAAiB,SAAAkC,GACFzB,OAAsB,MAAtBA,EAAW6B,OAEpBC,OAAFH,MAAgB,cAEZlB,EAAAsB,IAAA1B,EAAAgB,QAAAI,EAAAO,SACAxC,MAAqB,SAAAU,GAGTC,QAAAC,IAAA,qCAAoDF,EAAhEG,EAAAgB,QAAAC,OAGPG,KAEOnB,MAAN,SAAAJ,GAEEV,OADAW,QAAAC,IAAA,mCAAAF,GACqBK,OAAAoB,MAFvB,qBA7BW1B,MAAM,SAAAC,GAoCrBC,QAAAC,IAAA,2CAAAF,OAGSV,MAAAA,SAAAA,GACPW,QAAAC,IAAA,wDAAAF,QAzBFhB,EAAEK,iBAAiB,UAAW,SAASc,GACX,YAAtBA,EAAM4B,KAAKjC,QACbK,EAAMC,UACJpB,EAAE4C,cACClC,KAAK,WAEJJ,EAAqB,eAEtBS,MAAM,SAAAC,GACLC,QAAQC,IAAI,mDAAoDF,MAI9C,YAAtBG,EAAM4B,KAAKjC,QACbK,EAAMC,UAEJd,EAAqB,gBApI3B,CAwJG0C","file":"sw.js","sourcesContent":["((s) => {\n'use strict';\nconst SW_VERSION = 1,\n  ORIGIN = 'NYC-RR-',\n  STATIC_CACHE = `${ORIGIN}static-cache-v${SW_VERSION}`,\n  DYNAMIC_CACHE = `${ORIGIN}dynamic-cache-v${SW_VERSION}`,\n  RESOURCES_TO_CACHE = [\n    '/',\n    '/index.html',\n    '/restaurant.html',\n    '/css/styles.css',\n    '/js/app.js',\n    '/js/main.js',\n    '/img/image-fallback.svg',\n    '/js/intersection-observer.js',\n    '/404.html',\n    '/offline.html'\n    /* Unfortunally Service Worker 'fetch' event does not trigger for favicon in Chrome. This bug is still open. https://bugs.chromium.org/p/chromium/issues/detail?id=448427 */\n];\n\n/**\n * Cache the main assets while installing SW.\n */\ns.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(STATIC_CACHE)\n      .then(cache => {\n        return cache.addAll(RESOURCES_TO_CACHE);\n      })\n      .catch(error => {\n        console.log('[SW] Installation failed, error:', error);\n      })\n  );\n});\n\n/**\n * Remove outdated caches while a new SW is activating.\n */\ns.addEventListener('activate', event => {\n  event.waitUntil(\n    caches.keys()\n      .then(cacheNames => {\n        return Promise.all(\n          cacheNames.filter(cacheName => {\n            // Caches are shared across the whole origin.\n            return (cacheName.startsWith(ORIGIN) && cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE);\n          }).map(cacheName => {\n            return caches.delete(cacheName);\n          })\n        );\n      })\n      .then(() => {\n        /* Allow the active service worker to set itself as the controller for all clients within its scope. This triggers a \"controllerchange\" event on navigator.serviceWorker in any clients that become controlled by this service worker. https://developer.mozilla.org/en-US/docs/Web/API/Clients/claim */\n        return s.clients.claim();\n      })\n      .catch(error => {\n        console.log('[SW] Activation failed, error:', error);\n      })\n  );\n});\n\n/**\n * Cache other resources dynamically with a fallback to the network.\n */\ns.addEventListener('fetch', event => {\n  /* The fetch handler serves responses only for same-origin resources. */\n  if (event.request.url.startsWith(s.location.origin)) {\n    if (event.request.url.indexOf('restaurant.html') > -1) {\n      if (event.request.url.search(/id=./) === -1) {\n        event.respondWith(\n          caches.match('/404.html')\n        );\n        return;\n      }\n      event.respondWith(\n        caches.match('/restaurant.html')\n      );\n    } else {\n      event.respondWith(\n        caches.match(event.request)\n          .then(response => {\n            if (response) return response;\n            return caches.open(DYNAMIC_CACHE)\n              .then(cache => {\n                return fetch(event.request)\n                  .then(response => {\n                    if (response.status === 404) {\n                      return caches.match('/404.html');\n                    }\n                    cache.put(event.request, response.clone())\n                      .catch(error => {\n                        /* In some cases dynamic caching fails: e.g. it's not possible to cache a resource because a \"DOMException: Quota exceeded\" error fires. */\n                        console.log('[SW] Dynamic caching failed, error', error, event.request.url);\n                      });\n                    return response;\n                  })\n                  .catch(error => {\n                    console.log('[SW] Fetch request failed, error', error);\n                    return caches.match('/offline.html');\n                  });\n              })\n              .catch(error => {\n                console.log('[SW] Opening dynamic cache failed, error', error);\n              });\n          })\n          .catch(error => {\n            console.log('[SW] Something failed while matching a request, error', error);\n          })\n      );\n    }\n  }\n});\n\n/**\n * Listen messages from client.\n */\ns.addEventListener('message', function(event) {\n  if (event.data.action === 'refresh') {\n    event.waitUntil(\n      s.skipWaiting() // Activate a new SW that is waiting.\n        .then(() => {\n          /* After receiving a message from one client, the new SW turns the message to all clients. */\n          sendMessageToClients('refreshed');\n        })\n        .catch(error => {\n          console.log('[SW] Something failed while skipping wait, error', error);\n        })\n    );\n  }\n  if (event.data.action === 'dismiss') {\n    event.waitUntil(\n      /* After receiving a message from one client, the current SW turns the message to all clients. */\n      sendMessageToClients('dismissed')\n    );\n  }\n});\n\n/**\n * Send a message to all clients.\n */\nfunction sendMessageToClients(message) {\n  /* Get a list of SW Client objects, and send a message to everyone. */\n  s.clients.matchAll()\n    .then(clients => {\n      clients.forEach(client => {\n        client.postMessage({action: message});\n      });\n    })\n    .catch(error => {\n      console.log('[SW] Something failed while sending message to clients, error', error);\n    });\n}\n})(self);\n"]}