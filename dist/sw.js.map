{"version":3,"sources":["sw.js"],"names":["s","ORIGIN","STATIC_CACHE","SW_VERSION","DYNAMIC_CACHE","RESOURCES_TO_CACHE","port","RESTAURANTS_URL","RESTAURANT_REVIEWS_URL","RESTAURANT_REVIEWS_ID_URL","addEventListener","event","handleOfflineRequestForRestaurant","restaurantId","indexedDB","open","onsuccess","handleOfflineRequestForReview","db","target","result","objectStore","get","fetch","store","is_favorite","method","request","then","data","ok","offline_request","response","statusText","body","JSON","transaction","catch","error","console","log","reviewId","onerror","id","stringify","headers","Headers","restaurant_id","sendMessageToClients","Error","json","waitUntil","delete","put","review","action","indexOf","message","clients","matchAll","forEach","client","postMessage","caches","cache","addAll","Promise","keys","cacheNames","all","filter","cacheName","startsWith","claim","respondWith","url","location","origin","search","match","status","clone","tag","parseInt","slice","self"],"mappings":"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","file":"sw.js","sourcesContent":["((s) => {\n'use strict';\nconst SW_VERSION = 1,\n      ORIGIN = 'NYC-RR-',\n      STATIC_CACHE = `${ORIGIN}static-cache-v${SW_VERSION}`,\n      DYNAMIC_CACHE = `${ORIGIN}dynamic-cache-v${SW_VERSION}`,\n      RESOURCES_TO_CACHE = [\n        '/',\n        '/index.html',\n        '/restaurant.html',\n        '/css/styles.css',\n        '/js/app.js',\n        '/js/main.js',\n        '/img/image-fallback.svg',\n        '/js/intersection-observer.js',\n        '/404.html',\n        '/offline.html'\n        /* Unfortunally Service Worker 'fetch' event does not trigger for favicon in Chrome. This bug is still open. https://bugs.chromium.org/p/chromium/issues/detail?id=448427 */\n      ],\n      port = 1337,\n      RESTAURANTS_URL = `http://localhost:${port}/restaurants`,\n      RESTAURANT_REVIEWS_URL = `http://localhost:${port}/reviews`,\n      RESTAURANT_REVIEWS_ID_URL = `${RESTAURANT_REVIEWS_URL}/?restaurant_id=`;\n\n/**\n * Cache the main assets while installing SW.\n */\ns.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(STATIC_CACHE)\n      .then(cache => {\n        return cache.addAll(RESOURCES_TO_CACHE);\n      })\n      .catch(error => {\n        console.log('[SW] Installation failed, error:', error);\n      })\n  );\n});\n\n/**\n * Remove outdated caches while a new SW is activating.\n */\ns.addEventListener('activate', event => {\n  event.waitUntil(\n    caches.keys()\n      .then(cacheNames => {\n        return Promise.all(\n          cacheNames.filter(cacheName => {\n            // Caches are shared across the whole origin.\n            return (cacheName.startsWith(ORIGIN) && cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE);\n          }).map(cacheName => {\n            return caches.delete(cacheName);\n          })\n        );\n      })\n      .then(() => {\n        /* Allow the active service worker to set itself as the controller for all clients within its scope. This triggers a \"controllerchange\" event on navigator.serviceWorker in any clients that become controlled by this service worker. https://developer.mozilla.org/en-US/docs/Web/API/Clients/claim */\n        return s.clients.claim();\n      })\n      .catch(error => {\n        console.log('[SW] Activation failed, error:', error);\n      })\n  );\n});\n\n/**\n * Cache other resources dynamically with a fallback to the network.\n */\ns.addEventListener('fetch', event => {\n  /* The fetch handler serves responses only for same-origin resources. */\n  if (event.request.url.startsWith(s.location.origin)) {\n    if (event.request.url.indexOf('restaurant.html') > -1) {\n      if (event.request.url.search(/id=./) === -1) {\n        event.respondWith(\n          caches.match('/404.html')\n        );\n        return;\n      }\n      event.respondWith(\n        caches.match('/restaurant.html')\n      );\n    } else {\n      event.respondWith(\n        caches.match(event.request)\n          .then(response => {\n            if (response) return response;\n            return caches.open(DYNAMIC_CACHE)\n              .then(cache => {\n                return fetch(event.request)\n                  .then(response => {\n                    if (response.status === 404) {\n                      return caches.match('/404.html');\n                    }\n                    cache.put(event.request, response.clone())\n                      .catch(error => {\n                        /* In some cases dynamic caching fails: e.g. it's not possible to cache a resource because a \"DOMException: Quota exceeded\" error fires. */\n                        console.log('[SW] Dynamic caching failed, error', error, event.request.url);\n                      });\n                    return response;\n                  })\n                  .catch(error => {\n                    console.log('[SW] Fetch request failed, error', error);\n                    return caches.match('/offline.html');\n                  });\n              })\n              .catch(error => {\n                console.log('[SW] Opening dynamic cache failed, error', error);\n              });\n          })\n          .catch(error => {\n            console.log('[SW] Something failed while matching a request, error', error);\n          })\n      );\n    }\n  }\n});\n\n\n/**\n * Listen for background sync tags.\n */\ns.addEventListener('sync', event => {\n  if (event.tag.indexOf('favorite-sync-') > -1) {\n    event.waitUntil((() => {\n      const restaurantId = parseInt(event.tag.slice(14));\n      handleOfflineRequestForRestaurant(restaurantId);\n    })());\n  } else if (event.tag.indexOf('review-sync-') > -1) {\n    event.waitUntil((() => {\n      const reviewId = event.tag.slice(12);\n      handleOfflineRequestForReview(reviewId);\n    })());\n  }\n});\n\n/**\n * Function to handle offline request for a restaurant.\n */\nfunction handleOfflineRequestForRestaurant(restaurantId) {\n  // Open a connection with indexedDB.\n  const request = s.indexedDB.open(`nyc_rr_data`, 1);\n\n  // Open a transaction and obtain a reference to the object store.\n  request.onsuccess = event => {\n    const db = event.target.result,\n          store = db.transaction(['restaurants'], 'readonly').objectStore('restaurants'),\n          request = store.get(restaurantId); // Get data from indexedDB.\n\n    // Update database on network with fetch API.\n    request.onsuccess = event => {\n      fetch(`${RESTAURANTS_URL}/${restaurantId}/?is_favorite=${event.target.result.is_favorite}`, {\n        method: 'PUT'\n      })\n      .then(() => {\n        fetch(`${RESTAURANTS_URL}/${restaurantId}`)\n          .then(response => {\n            if (!response.ok) {\n              throw Error(`Request failed. Returned status of ${response.statusText}`);\n            }\n            return response.json();\n          })\n          .then(restaurant => {\n            // Open a transaction.\n            const store = db.transaction(['restaurants'], 'readwrite').objectStore('restaurants');\n\n            // Update data into the object store.\n            store.put(restaurant);\n          });\n      })\n      .catch(error => {\n        console.log(error);\n      });\n    };\n  };\n}\n\n/**\n * Function to handle offline request for a review.\n */\nfunction handleOfflineRequestForReview(reviewId) {\n  // Open a connection with indexedDB.\n  const request = s.indexedDB.open(`nyc_rr_data`, 1);\n\n  // Open a transaction and obtain a reference to the object store.\n  request.onsuccess = event => {\n    const db = event.target.result,\n          store = db.transaction(['reviews'], 'readonly').objectStore('reviews'),\n          request = store.get(reviewId); // Get data from indexedDB.\n\n    // Update database on network with fetch API.\n    request.onsuccess = event => {\n      let data = event.target.result;\n      delete data.id;\n      delete data.offline_request;\n\n      fetch(RESTAURANT_REVIEWS_URL, {\n        method: 'POST',\n        body: JSON.stringify(data),\n        headers: new Headers({\n          'Content-Type': 'application/json'\n        })\n      })\n      .then(() => {\n        fetch(`${RESTAURANT_REVIEWS_ID_URL}${data.restaurant_id}`)\n          .then(response => {\n            if (!response.ok) {\n              throw Error(`Request failed. Returned status of ${response.statusText}`);\n            }\n            return response.json();\n          })\n          .then(reviews => {\n            const store = db.transaction(['reviews'], 'readwrite').objectStore('reviews'),\n                  request = store.delete(reviewId);\n\n            request.onerror = event => {\n              console.log(event.target.error);\n            };\n\n            // Save data into the object store.\n            reviews.forEach(review => {\n              const store = db.transaction(['reviews'], 'readwrite').objectStore('reviews'),\n              request = store.put(review);\n\n              request.onerror = event => {\n                console.log(event.target.error);\n              };\n            });\n          });\n      })\n      .catch(error => {\n        console.log(error);\n      });\n    };\n  };\n}\n\n/**\n * Listen messages from client.\n */\ns.addEventListener('message', function(event) {\n  if (event.data.action === 'refresh') {\n    event.waitUntil(\n      s.skipWaiting() // Activate a new SW that is waiting.\n        .then(() => {\n          /* After receiving a message from one client, the new SW turns the message to all clients. */\n          sendMessageToClients('refreshed');\n        })\n        .catch(error => {\n          console.log('[SW] Something failed while skipping wait, error', error);\n        })\n    );\n  }\n  if (event.data.action === 'dismiss') {\n    event.waitUntil(\n      /* After receiving a message from one client, the current SW turns the message to all clients. */\n      sendMessageToClients('dismissed')\n    );\n  }\n\n  /* Listen for messages to handle forgotten offline requests for restaurants. */\n  if (event.data.action.indexOf('favorite-sync-') > -1) {\n    event.waitUntil((() => {\n      const restaurantId = parseInt(event.data.action.slice(14));\n      handleOfflineRequestForRestaurant(restaurantId);\n    })());\n  }\n\n  /* Listen for messages to handle forgotten offline requests for reviews. */\n  if (event.data.action.indexOf('review-sync-') > -1) {\n    event.waitUntil((() => {\n      const reviewId = event.data.action.slice(12);\n      handleOfflineRequestForReview(reviewId);\n    })());\n  }\n});\n\n/**\n * Send a message to all clients.\n */\nfunction sendMessageToClients(message) {\n  /* Get a list of SW Client objects, and send a message to everyone. */\n  s.clients.matchAll()\n    .then(clients => {\n      clients.forEach(client => {\n        client.postMessage({action: message});\n      });\n    })\n    .catch(error => {\n      console.log('[SW] Something failed while sending message to clients, error', error);\n    });\n}\n})(self);\n"]}