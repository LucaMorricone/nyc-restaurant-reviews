{"version":3,"sources":["sw.js"],"names":["s","ORIGIN","STATIC_CACHE","DYNAMIC_CACHE","RESOURCES_TO_CACHE","addEventListener","sendMessageToClients","message","clients","matchAll","then","forEach","client","postMessage","action","catch","error","console","log","event","waitUntil","caches","open","keys","cacheName","cacheNames","Promise","all","filter","startsWith","map","request","respondWith","response","location","origin","url","indexOf","search","match","cache","fetch","skipWaiting","status","clone","data","self"],"mappings":"cAAA,SAAEA,GAAD,IACCC,EAAA,UAGEC,EAAkBD,EAAlB,kBAFFE,EAAAF,EAAA,mBAAAG,EAAA,CAEEF,IACAC,cACAC,mBAWE,kBACA,cANA,kBASJ,eAPI,yBACA,YASFC,gBAIM,gBAiHR,SAASC,EAAqBC,GAE5BP,EAAEQ,QAAQC,WACPC,KAAK,SAAAF,GACJA,EAAQG,QAAQ,SAAAC,GACdA,EAAOC,YAAY,CAACC,OAAQP,QAG/BQ,MAAM,SAAAC,GACLC,QAAQC,IAAI,gEAAiEF,KAlHnFhB,EAAAK,iBAAA,UAAA,SAAAc,GAXEA,EAAMC,UACJC,OAAOC,KAAKpB,GAadG,KAAAA,SAAAA,GACMe,OAAAA,EACJC,OAAOE,KAICR,MAAA,SAAAC,GACAC,QAAQO,IAAAA,mCAAgCA,QAW5CP,EAAAA,iBAAY,WAAA,SAAAE,GACbA,EAlBLC,UADFC,OAAAE,OAGOb,KAAK,SAAAe,GAoBZ,OAAAC,QAAAC,IAlBUF,EAAWG,OAAO,SAAAJ,GAqB1BnB,OAAiBmB,EAASK,WAAA5B,IAASuB,IAAAtB,GAAAsB,IAAArB,IACnC2B,IAAA,SAAAN,GACUO,OAANV,OAAkBQ,OAAAA,QAMhBnB,KAAA,WAEFS,OAAMa,EAAAA,QACJX,UAGFF,MAAMa,SAAAA,GAGAf,QAAIgB,IAAJ,iCAAcjB,QAWFC,EAAAA,iBAAAA,QAAY,SAAAE,GAEhB,GAAAA,EAAAY,QAAOE,IAAAA,WAAPjC,EAAAkC,SAAAC,QACD,IACe,EADfhB,EACAJ,QAAMqB,IAAAC,QAAA,mBAAS,CACdpB,IAAY,IAAZA,EAAAA,QAAYmB,IAAAE,OAAA,QAKhBrB,YAJIE,EAAAa,YACDX,OAfHkB,MAAA,cAoBLpB,EACAJ,YACCE,OAAAA,MAAY,0BAIrBE,EAAAa,YA9CHX,OAAAkB,MAAApB,EAAAY,SAgBWrB,KAAK,SAAAuB,GAiChB,OAAAA,GA/BmBZ,OAAOC,KAAKnB,GAChBO,KAAK,SAAA8B,GAiClBnC,OAAiBoC,MAAnBtB,EAA8BY,SACbjB,KAAX,SAAAmB,GAEAjC,OAAgB,MAAd0C,EAAFC,OACctB,OAAAkB,MAAA,cAEVjC,EAAAA,IAAqBa,EAAAY,QAArBE,EAAAW,SAEK7B,MAAA,SAAAC,GANXC,QAAAC,IAAA,qCAAAF,EAAAG,EAAAY,QAAAK,OAWEH,KAEAlB,MAAA,SAAAC,GAGH,OAFGV,QAAqBY,IAAA,mCAFvBF,GAIDK,OAAAkB,MAAA,qBAGHxB,MAAA,SAAAC,GAnCgBC,QAAQC,IAAI,2CAA4CF,OAuCtED,MAAA,SAAAC,GACUP,QAAVS,IACGR,wDAAgBM,QA3BrBhB,EAAEK,iBAAiB,UAAW,SAASc,GACX,YAAtBA,EAAM0B,KAAK/B,QACbK,EAAMC,UACJpB,EAAE0C,cACChC,KAAK,WAEJJ,EAAqB,eAEtBS,MAAM,SAAAC,GACLC,QAAQC,IAAI,mDAAoDF,MAI9C,YAAtBG,EAAM0B,KAAK/B,QACbK,EAAMC,UAEJd,EAAqB,gBArI7B,CAyJGwC","file":"sw.js","sourcesContent":["((s) => {\n  'use strict';\n  const SW_VERSION = 1,\n    ORIGIN = 'NYC-RR-',\n    STATIC_CACHE = `${ORIGIN}static-cache-v${SW_VERSION}`,\n    DYNAMIC_CACHE = `${ORIGIN}dynamic-cache-v${SW_VERSION}`,\n    RESOURCES_TO_CACHE = [\n      '/',\n      '/index.html',\n      '/restaurant.html',\n      '/css/styles.css',\n      '/js/main.js',\n      '/js/dbhelper.js',\n      '/js/index.js',\n      '/js/restaurant_info.js',\n      '/404.html',\n      '/offline.html',\n      /* Unfortunally Service Worker 'fetch' event does not trigger for favicons in Chrome. This bug is still open. https://bugs.chromium.org/p/chromium/issues/detail?id=448427 */\n      '/favicon.ico'\n  ];\n\n  /**\n   * Cache the main assets while installing SW.\n   */\n  s.addEventListener('install', event => {\n    event.waitUntil(\n      caches.open(STATIC_CACHE)\n        .then(cache => {\n          return cache.addAll(RESOURCES_TO_CACHE);\n        })\n        .catch(error => {\n          console.log('[SW] Installation failed, error:', error);\n        })\n    );\n  });\n\n  /**\n   * Remove outdated caches while a new SW is activating.\n   */\n  s.addEventListener('activate', event => {\n    event.waitUntil(\n      caches.keys()\n        .then(cacheNames => {\n          return Promise.all(\n            cacheNames.filter(cacheName => {\n              // Caches are shared across the whole origin.\n              return (cacheName.startsWith(ORIGIN) && cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE);\n            }).map(cacheName => {\n              return caches.delete(cacheName);\n            })\n          );\n        })\n        .then(() => {\n          /* Allow the active service worker to set itself as the controller for all clients within its scope. This triggers a \"controllerchange\" event on navigator.serviceWorker in any clients that become controlled by this service worker. https://developer.mozilla.org/en-US/docs/Web/API/Clients/claim */\n          return s.clients.claim();\n        })\n        .catch(error => {\n          console.log('[SW] Activation failed, error:', error);\n        })\n    );\n  });\n\n  /**\n   * Cache other resources dynamically with a fallback to the network.\n   */\n  s.addEventListener('fetch', event => {\n    /* The fetch handler serves responses only for same-origin resources. */\n    if (event.request.url.startsWith(s.location.origin)) {\n      if (event.request.url.indexOf('restaurant.html') > -1) {\n        if (event.request.url.search(/id=./) === -1) {\n          event.respondWith(\n            caches.match('/404.html')\n          );\n          return;\n        }\n        event.respondWith(\n          caches.match('/restaurant.html')\n        );\n      } else {\n        event.respondWith(\n          caches.match(event.request)\n            .then(response => {\n              if (response) return response;\n              return caches.open(DYNAMIC_CACHE)\n                .then(cache => {\n                  return fetch(event.request)\n                    .then(response => {\n                      if (response.status === 404) {\n                        return caches.match('/404.html');\n                      }\n                      cache.put(event.request, response.clone())\n                        .catch(error => {\n                          /* In some cases dynamic caching fails: e.g. it's not possible to cache a resource because a \"DOMException: Quota exceeded\" error fires. */\n                          console.log('[SW] Dynamic caching failed, error', error, event.request.url);\n                        });\n                      return response;\n                    })\n                    .catch(error => {\n                      console.log('[SW] Fetch request failed, error', error);\n                      return caches.match('/offline.html');\n                    });\n                })\n                .catch(error => {\n                  console.log('[SW] Opening dynamic cache failed, error', error);\n                });\n            })\n            .catch(error => {\n              console.log('[SW] Something failed while matching a request, error', error);\n            })\n        );\n      }\n    }\n  });\n\n  /**\n   * Listen messages from client.\n   */\n  s.addEventListener('message', function(event) {\n    if (event.data.action === 'refresh') {\n      event.waitUntil(\n        s.skipWaiting() // Activate a new SW that is waiting.\n          .then(() => {\n            /* After receiving a message from one client, the new SW turns the message to all clients. */\n            sendMessageToClients('refreshed');\n          })\n          .catch(error => {\n            console.log('[SW] Something failed while skipping wait, error', error);\n          })\n      );\n    }\n    if (event.data.action === 'dismiss') {\n      event.waitUntil(\n        /* After receiving a message from one client, the current SW turns the message to all clients. */\n        sendMessageToClients('dismissed')\n      );\n    }\n  });\n\n  /**\n   * Send a message to all clients.\n   */\n  function sendMessageToClients(message) {\n    /* Get a list of SW Client objects, and send a message to everyone. */\n    s.clients.matchAll()\n      .then(clients => {\n        clients.forEach(client => {\n          client.postMessage({action: message});\n        });\n      })\n      .catch(error => {\n        console.log('[SW] Something failed while sending message to clients, error', error);\n      });\n  }\n})(self);"]}