{"version":3,"sources":["js/dbhelper.js"],"names":["w","indexedDB","console","open","request","onupgradeneeded","event","target","result","createObjectStore","keyPath","db","log","DBHelper","window","onsuccess","Promise","transaction","objectStore","resolve","reject","IDBRestaurants","cursor","store","length","push","value","fetch","DATABASE_URL","then","response","ok","statusText","Error","restaurants","forEach","restaurant","catch","error","openCursor","onerror","errorCode","json","fetchRestaurants","neighborhoods","map","v","i","neighborhood","filter","indexOf","uniqueNeighborhoods","cuisines","cuisine_type","cuisine","results","r","id","width","srcsetStr","imageUrlForRestaurant","join","google","maps","Marker","position","latlng","title","name","url","urlForRestaurant","animation","Animation","DROP"],"mappings":"AAAA,8XAEA,SAAEA,IAAD,WAMG,GAAKA,EAAEC,UAAP,CACEC,IAAAA,EAAYF,EAAAC,UAAAE,KAAA,cAAZ,GACAC,EAAAC,gBAAA,SAAAC,GACDA,EAAAC,OAAAC,OACDC,kBAAA,cAAA,CAAAC,QAAA,QAGEN,EAAMO,QAAWJ,SAAAA,GACjBI,QAAGF,IAAAA,mBAAkBH,EAAgBI,OAAAA,iBAPrCR,QAAQU,IAAI,2BAPjB,GAAD,CAiBIR,YASES,8HAgBF,GAAIC,OAAOb,UAAW,CADtB,IAAAG,EAAAU,OAAAb,UAAAE,KAAA,eAGE,OAAMC,IAAAA,QAAUU,SAAAA,EAAOb,GAEvBG,EAAAW,UAAA,SAAAT,GACA,IAAOK,EAAIK,EAAQT,OAAAC,OAEjBJ,EAAQW,EAARE,YAAoB,CAAA,eAAS,aAAAC,YAAA,eAE3BC,EAAA,IAAAH,QAAA,SAAAG,EAAAC,GAKE,IAAIC,EAAiB,GAFvBF,EAAAA,aAAQJ,UAAaI,SAAAA,GACnB,IAAAG,EAAAhB,EAAAC,OAAAC,OAEAe,GAAAF,EAA+BG,OAwBtBF,GACLD,EAAAI,KAAAH,EAAAI,OACAL,EAAAA,YAGAF,EAAAE,GA3BFF,EAAAQ,MAAAd,EAAAe,cACAC,KAAKP,SAAAA,GACH,IAAAQ,EAAAC,GACAZ,MAAQQ,MAAAA,sCACAG,EAAYE,YAEd,OAAAF,EAAMG,SAERJ,KAAA,SAAAK,GAGA,IAAAX,EAAAZ,EAAAM,YAAA,CAAA,eAAA,aAAAC,YAAA,eAKC,OAHDgB,EAAAC,QAAA,SAAAC,GACAF,EAAAA,IAAYC,KAAZD,IAXIG,MAgBLA,SAAAA,GACCnC,QAAQU,IAAI0B,OAUnBf,EAhCDgB,aAAAC,QAAA,SAAAlC,GAiCAiB,EAAMgB,EAAAA,OAAaC,gBAItBpC,EA7CDoC,QAAA,SAAAlC,GA8CAF,EAAAA,EAAQoC,OAAUC,cAIrB,OAAMd,MAAAd,EAAAe,cAAEC,KAAA,SAAAC,GACP,IAAOH,EAAMd,GAET,MAAKiB,MAAAA,sCAAaA,EAAAE,YAEjB,OAAAF,EAAAY,SAJEb,KAOJA,SAAAA,GACC,OAAOK,IAGPhC,MAAAA,SAAAA,GAXJA,QAAAU,IAAA0B,kDAqBF,OAAOzB,EAAS8B,mBADhBd,KAAA,SAAAK,GAGI,IAAAU,EAAAV,EAAAW,IAAA,SAAAC,EAAAC,GAAA,OAAAb,EAAAa,GAAAC,eACsC,OAAyBA,EAAzBC,OAAA,SAAAH,EAAAC,GAAA,OAAAH,EAAAM,QAAAJ,KAAAC,MAEtCV,MAAMc,SAAAA,GAA2CjD,QAAAU,IAAUgC,6CAa/D,OAAO/B,EAAS8B,mBACbd,KAAK,SAAAK,GAEJ,IAAMkB,EAAWlB,EAAYW,IAAI,SAACC,EAAGC,GAAJ,OAAUb,EAAYa,GAAGM,eAJ9D,OAM2BD,EAPNH,OAAA,SAAAH,EAAAC,GAAA,OAAAK,EAAAF,QAAAJ,KAAAC,MAIjBV,MAAA,SAAAC,GACApC,QAAMkD,IAAAA,qEAGNE,EAAAN,GAGA9C,OAAAA,EAAYoC,mBATTT,KAAP,SAAAK,GAWD,IAAAqB,EAAArB,EAgBK,MANe,OAAXoB,IARVC,EAAAA,EAAAN,OAAA,SAAAO,GAAA,OAAAA,EAAAH,eAAAC,KAW0B,OAAhBN,IACFO,EAAUA,EAAQN,OAAO,SAAAO,GAAA,OAAKA,EAAER,eAAiBA,KAE5CO,IAVXlB,MAAA,SAAAC,GACApC,QAAOW,IAAAA,iDAKF4C,GAC4B,OAAA5C,EAAA8B,mBAC3BY,KAAAA,SAAAA,GAAyB,IAAAnB,EAAOY,EAAiBA,KAAAA,SAAAA,GAAAA,OAAAA,EAAxBS,IAAAA,IAAA,IAAzBrB,EACD,MAAAH,MAAA,6BARE,OAWEG,IAXFC,MAAP,SAAAC,GAcDpC,QAAAU,IAAA0B,mDAuB4BF,EAAYsB,GAdC,MAAA,SAA9BtB,EAAaF,YAAiB,qBAAA,IAAAwB,EAAA,6CAI7BtB,GAGPlC,IAFD,IAPIyD,EAQE,GACLzD,EAAQU,EAAI0B,EAAAA,EAAZtC,IACD2D,EAVHlC,KAAAZ,EAAA+C,sBAAAxB,EAAA,IAAApC,GAUG,IAVH,IAAAA,EAUG,KAsBH,OAAO2D,EAAUE,KAAK,+CAMAzB,GACtB,MAAA,uBAA+BA,EAvBJA,kDAM5BA,EAAAS,GA+BC,OAPe,IAAIiB,OAAOC,KAAKC,OAAO,CAtBxCC,SAAA7B,EAAA8B,OAwBIC,MAAU/B,EAAWgC,KAArB,IAA6BhC,EAAWY,aACxCqB,IAAKxD,EAASyD,iBAAiBlC,GAC/BS,IAAKA,EACL0B,UAAWT,OAAOC,KAAKS,UAAUC,wDAlBpCnB,GAED,OAAAzC,EAAA8B,mBA2BKd,KAAK,SAAAK,GAEJ,OAAOA,EAAYe,OAAO,SAAAO,GAAA,OAAKA,EAAEH,cAAgBC,MAElDjB,MAAM,SAAAC,GACLpC,QAAQU,IAAI0B,2DAOmBU,GAEnC,OAAOnC,EAAS8B,mBACbd,KAAK,SAAAK,GA9BN+B,OAAAA,EAAU7B,OAAW8B,SAAAA,GAAAA,OADeV,EAAAR,cAAAA,MAGpCqB,MAAKxD,SAAAA,GACLgC,QAJoCjC,IAAA0B,0CA9LtC,MAAA","file":"dbhelper.js","sourcesContent":["'use strict';\r\n\r\n((w) => {\r\n  /**\r\n   * IndexedDB.\r\n   */\r\n  (() => {\r\n    // Check if indexedDB is supported.\r\n    if (!w.indexedDB) {\r\n      console.log('IndexedDB not supported');\r\n      return;\r\n    }\r\n    // Open a connection with indexedDB and create the object store.\r\n    const request = w.indexedDB.open('nyc_rr_data', 1);\r\n    request.onupgradeneeded = event => {\r\n      const db = event.target.result;\r\n      db.createObjectStore('restaurants', {keyPath: 'id'});\r\n    };\r\n    // Handle error.\r\n    request.onerror = event => {\r\n      console.log('Database error: ', event.target.errorCode);\r\n    };\r\n  })();\r\n})(window);\r\n\r\n/**\r\n * Common database helper functions.\r\n */\r\nclass DBHelper {\r\n\r\n  /**\r\n   * Database URL.\r\n   * Change this to restaurants.json file location on your server.\r\n   */\r\n  static get DATABASE_URL() {\r\n    const port = 1337; // Change this to your server port.\r\n    return `http://localhost:${port}/restaurants`;\r\n  }\r\n\r\n  /**\r\n   * Fetch all restaurants with proper error handling.\r\n   */\r\n  static fetchRestaurants() {\r\n    // Check if indexedDB is supported.\r\n    if (window.indexedDB) {\r\n      // Open a connection with indexedDB.\r\n      const request = window.indexedDB.open('nyc_rr_data');\r\n\r\n      // The fetchRestaurants function must return a Promise.\r\n      return new Promise((resolve, reject) => {\r\n\r\n        request.onsuccess = event => {\r\n          const db = event.target.result;\r\n          // Open a transaction and obtain a reference to the object store.\r\n          const store = db.transaction(['restaurants'], 'readwrite').objectStore('restaurants');\r\n\r\n          resolve(new Promise((resolve, reject) => {\r\n            // Use cursors to retrieve all objects in the object store and add them to an array.\r\n            let IDBRestaurants = [];\r\n            store.openCursor().onsuccess = event => {\r\n              let cursor = event.target.result;\r\n              // Check if the object store is empty.\r\n              if (!cursor && !IDBRestaurants.length) {\r\n                // Fetch from the network.\r\n                resolve(fetch(DBHelper.DATABASE_URL)\r\n                  .then(response => {\r\n                    if (!response.ok) {\r\n                      throw Error(`Request failed. Returned status of ${response.statusText}`);\r\n                    }\r\n                    return response.json();\r\n                  })\r\n                  .then(restaurants => {\r\n                    // Open a transaction.\r\n                    const store = db.transaction(['restaurants'], 'readwrite').objectStore('restaurants');\r\n                    // Save data into the object store.\r\n                    restaurants.forEach(restaurant => {\r\n                      store.add(restaurant);\r\n                    });\r\n                    return restaurants;\r\n                  })\r\n                  .catch(error => {\r\n                    console.log(error);\r\n                  }));\r\n              } else if (cursor) { // Check the cursor.\r\n                // Save cursor value in an array.\r\n                IDBRestaurants.push(cursor.value);\r\n                cursor.continue();\r\n              } else {\r\n                // Return all data from indexedDB.\r\n                resolve(IDBRestaurants);\r\n              }\r\n            };\r\n            store.openCursor().onerror = event => {\r\n              reject(event.target.errorCode);\r\n            };\r\n          }));\r\n        };\r\n        request.onerror = event => {\r\n          reject(event.target.errorCode);\r\n        };\r\n      });\r\n    } else { // If indexedDB is not supported.\r\n      return fetch(DBHelper.DATABASE_URL)\r\n        .then(response => {\r\n          if (!response.ok) {\r\n            throw Error(`Request failed. Returned status of ${response.statusText}`);\r\n          }\r\n          return response.json();\r\n        })\r\n        .then(restaurants => {\r\n          return restaurants;\r\n        })\r\n        .catch(error => {\r\n          console.log(error);\r\n        });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch all neighborhoods with proper error handling.\r\n   */\r\n  static fetchNeighborhoods() {\r\n    // Fetch all restaurants.\r\n    return DBHelper.fetchRestaurants()\r\n      .then(restaurants => {\r\n        // Get all neighborhoods from all restaurants.\r\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood);\r\n        // Remove duplicates from neighborhoods.\r\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) === i);\r\n        return uniqueNeighborhoods;\r\n      })\r\n      .catch(error => {\r\n        console.log(error);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Fetch all cuisines with proper error handling.\r\n   */\r\n  static fetchCuisines() {\r\n    // Fetch all restaurants.\r\n    return DBHelper.fetchRestaurants()\r\n      .then(restaurants => {\r\n        // Get all cuisines from all restaurants.\r\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type);\r\n        // Remove duplicates from cuisines.\r\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) === i);\r\n        return uniqueCuisines;\r\n      })\r\n      .catch(error => {\r\n        console.log(error);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood) {\r\n    // Fetch all restaurants.\r\n    return DBHelper.fetchRestaurants()\r\n      .then(restaurants => {\r\n        let results = restaurants;\r\n        if (cuisine != 'all') { // Filter by cuisine.\r\n          results = results.filter(r => r.cuisine_type === cuisine);\r\n        }\r\n        if (neighborhood != 'all') { // Filter by neighborhood.\r\n          results = results.filter(r => r.neighborhood === neighborhood);\r\n        }\r\n        return results;\r\n      })\r\n      .catch(error => {\r\n        console.log(error);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Fetch a restaurant by its ID with proper error handling.\r\n   */\r\n  static fetchRestaurantById(id) {\r\n    // Fetch all restaurants with proper error handling.\r\n    return DBHelper.fetchRestaurants()\r\n      .then(restaurants => {\r\n        const restaurant = restaurants.find(r => r.id == id);\r\n        if (!restaurant) { // Restaurant does not exist in the database.\r\n          throw Error('Restaurant does not exist');\r\n        }\r\n        return restaurant; // Got the restaurant.\r\n      })\r\n      .catch(error => {\r\n        console.log(error);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Restaurant image URL.\r\n   */\r\n  static imageUrlForRestaurant(restaurant, width) {\r\n    /* const extension = restaurant.photograph.split('.').pop();\r\n    const name = restaurant.photograph.slice(0, restaurant.photograph.indexOf(`.${extension}`));\r\n    return (`/img/${name}-${width}w.${extension}`); */\r\n    const name = restaurant.photograph || 'image-placeholder';\r\n    return `/img/${name}-${width}w.jpg`;\r\n  }\r\n\r\n  /**\r\n   * Restaurant image srcset.\r\n   */\r\n  static formatSrcset(restaurant) {\r\n    let srcsetStr = [];\r\n    for (let w = 3; w < 9; w++) {\r\n      srcsetStr.push(`${DBHelper.imageUrlForRestaurant(restaurant, w*100)} ${w*100}w`);\r\n    }\r\n    return srcsetStr.join(', ');\r\n  }\r\n\r\n  /**\r\n   * Restaurant page URL.\r\n   */\r\n  static urlForRestaurant(restaurant) {\r\n    return (`/restaurant.html?id=${restaurant.id}`);\r\n  }\r\n\r\n  /**\r\n   * Map marker for a restaurant.\r\n   */\r\n  static mapMarkerForRestaurant(restaurant, map) {\r\n    const marker = new google.maps.Marker({\r\n      position: restaurant.latlng,\r\n      title: `${restaurant.name} ${restaurant.neighborhood}`,\r\n      url: DBHelper.urlForRestaurant(restaurant),\r\n      map: map,\r\n      animation: google.maps.Animation.DROP\r\n    });\r\n    return marker;\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine type with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisine(cuisine) {\r\n    // Fetch all restaurants.\r\n    return DBHelper.fetchRestaurants()\r\n      .then(restaurants => {\r\n        // Filter restaurants to have only given cuisine type.\r\n        return restaurants.filter(r => r.cuisine_type == cuisine);\r\n      })\r\n      .catch(error => {\r\n        console.log(error);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByNeighborhood(neighborhood) {\r\n    // Fetch all restaurants.\r\n    return DBHelper.fetchRestaurants()\r\n      .then(restaurants => {\r\n        // Filter restaurants to have only given neighborhood.\r\n        return restaurants.filter(r => r.neighborhood == neighborhood);\r\n      })\r\n      .catch(error => {\r\n        console.log(error);\r\n      });\r\n  }\r\n\r\n}\r\n"]}