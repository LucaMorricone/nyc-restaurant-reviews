{"version":3,"sources":["sw.js"],"names":["s","ORIGIN","STATIC_CACHE","SW_VERSION","DYNAMIC_CACHE","RESOURCES_TO_CACHE","port","RESTAURANTS_URL","RESTAURANT_REVIEWS_URL","RESTAURANT_REVIEWS_ID_URL","addEventListener","event","syncRestaurant","tagOrMessage","Promise","resolve","request","restaurantId","parseInt","slice","indexedDB","open","onsuccess","db","handleOfflineRequestForReview","store","transaction","objectStore","fetch","target","result","is_favorite","method","then","data","id","response","statusText","json","headers","Headers","put","restaurant","catch","error","console","log","syncReview","reviewId","reviews","forEach","onerror","get","offline_request","body","JSON","stringify","Content-Type","waitUntil","restaurant_id","sendMessageToClients","Error","delete","review","message","clients","matchAll","client","postMessage","action","caches","cache","addAll","keys","cacheNames","all","filter","cacheName","startsWith","claim","respondWith","url","location","origin","search","match","doSync","status","clone","tag","indexOf","handleOfflineRequestForRestaurant","self","skipWaiting"],"mappings":"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","file":"sw.js","sourcesContent":["((s) => {\n'use strict';\nconst SW_VERSION = 1,\n      ORIGIN = 'NYC-RR-',\n      STATIC_CACHE = `${ORIGIN}static-cache-v${SW_VERSION}`,\n      DYNAMIC_CACHE = `${ORIGIN}dynamic-cache-v${SW_VERSION}`,\n      RESOURCES_TO_CACHE = [\n        '/',\n        '/index.html',\n        '/restaurant.html',\n        '/css/styles.css',\n        '/js/app.js',\n        '/js/main.js',\n        '/img/image-fallback.svg',\n        '/js/intersection-observer.js',\n        '/404.html',\n        '/offline.html'\n        /* Unfortunally Service Worker 'fetch' event does not trigger for favicon in Chrome. This bug is still open. https://bugs.chromium.org/p/chromium/issues/detail?id=448427 */\n      ],\n      port = 1337,\n      RESTAURANTS_URL = `http://localhost:${port}/restaurants`,\n      RESTAURANT_REVIEWS_URL = `http://localhost:${port}/reviews`,\n      RESTAURANT_REVIEWS_ID_URL = `${RESTAURANT_REVIEWS_URL}/?restaurant_id=`;\n\n/**\n * Cache the main assets while installing SW.\n */\ns.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(STATIC_CACHE)\n      .then(cache => {\n        return cache.addAll(RESOURCES_TO_CACHE);\n      })\n      .catch(error => {\n        console.log('[SW] Installation failed, error:', error);\n      })\n  );\n});\n\n/**\n * Remove outdated caches while a new SW is activating.\n */\ns.addEventListener('activate', event => {\n  event.waitUntil(\n    caches.keys()\n      .then(cacheNames => {\n        return Promise.all(\n          cacheNames.filter(cacheName => {\n            // Caches are shared across the whole origin.\n            return (cacheName.startsWith(ORIGIN) && cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE);\n          }).map(cacheName => {\n            return caches.delete(cacheName);\n          })\n        );\n      })\n      .then(() => {\n        /* Allow the active service worker to set itself as the controller for all clients within its scope. This triggers a \"controllerchange\" event on navigator.serviceWorker in any clients that become controlled by this service worker. https://developer.mozilla.org/en-US/docs/Web/API/Clients/claim */\n        return s.clients.claim();\n      })\n      .catch(error => {\n        console.log('[SW] Activation failed, error:', error);\n      })\n  );\n});\n\n/**\n * Cache other resources dynamically with a fallback to the network.\n */\ns.addEventListener('fetch', event => {\n  /* The fetch handler serves responses only for same-origin resources. */\n  if (event.request.url.startsWith(s.location.origin)) {\n    if (event.request.url.indexOf('restaurant.html') > -1) {\n      if (event.request.url.search(/id=./) === -1) {\n        event.respondWith(\n          caches.match('/404.html')\n        );\n        return;\n      }\n      event.respondWith(\n        caches.match('/restaurant.html')\n      );\n    } else {\n      event.respondWith(\n        caches.match(event.request)\n          .then(response => {\n            if (response) return response;\n            return caches.open(DYNAMIC_CACHE)\n              .then(cache => {\n                return fetch(event.request)\n                  .then(response => {\n                    if (response.status === 404) {\n                      return caches.match('/404.html');\n                    }\n                    cache.put(event.request, response.clone())\n                      .catch(error => {\n                        /* In some cases dynamic caching fails: e.g. it's not possible to cache a resource because a \"DOMException: Quota exceeded\" error fires. */\n                        console.log('[SW] Dynamic caching failed, error', error, event.request.url);\n                      });\n                    return response;\n                  })\n                  .catch(error => {\n                    console.log('[SW] Fetch request failed, error', error);\n                    return caches.match('/offline.html');\n                  });\n              })\n              .catch(error => {\n                console.log('[SW] Opening dynamic cache failed, error', error);\n              });\n          })\n          .catch(error => {\n            console.log('[SW] Something failed while matching a request, error', error);\n          })\n      );\n    }\n  }\n});\n\n/**\n * Listen for background sync tags.\n */\ns.addEventListener('sync', event => {\n  event.waitUntil(doSync(event));\n});\n\n/**\n * Do something on background sync.\n */\nfunction doSync(event) {\n  return new Promise(resolve => {\n    if (event.tag.indexOf('favorite-sync-') > -1) {\n      resolve(syncRestaurant(event.tag));\n    } else if (event.tag.indexOf('review-sync-') > -1) {\n      resolve(syncReview(event.tag));\n    }\n  });\n}\n\n/**\n * Do something for background sync of restaurant.\n */\nfunction syncRestaurant(tagOrMessage) {\n  return new Promise(resolve => {\n    const restaurantId = parseInt(tagOrMessage.slice(14));\n    handleOfflineRequestForRestaurant(restaurantId);\n    resolve();\n  });\n}\n\n/**\n * Do something for background sync of review.\n */\nfunction syncReview(tagOrMessage) {\n  return new Promise(resolve => {\n    const reviewId = tagOrMessage.slice(12);\n    handleOfflineRequestForReview(reviewId);\n    resolve();\n  });\n}\n\n/**\n * Function to handle offline request for a restaurant.\n */\nfunction handleOfflineRequestForRestaurant(restaurantId) {\n  // Open a connection with indexedDB.\n  const request = s.indexedDB.open(`nyc_rr_data`, 1);\n\n  // Open a transaction and obtain a reference to the object store.\n  request.onsuccess = event => {\n    const db = event.target.result,\n          store = db.transaction(['restaurants'], 'readonly').objectStore('restaurants'),\n          request = store.get(restaurantId); // Get data from indexedDB.\n\n    // Update database on network with fetch API.\n    request.onsuccess = event => {\n      fetch(`${RESTAURANTS_URL}/${restaurantId}/?is_favorite=${event.target.result.is_favorite}`, {\n        method: 'PUT'\n      })\n      .then(() => {\n        fetch(`${RESTAURANTS_URL}/${restaurantId}`)\n          .then(response => {\n            if (!response.ok) {\n              throw Error(`Request failed. Returned status of ${response.statusText}`);\n            }\n            return response.json();\n          })\n          .then(restaurant => {\n            // Open a transaction.\n            const store = db.transaction(['restaurants'], 'readwrite').objectStore('restaurants');\n\n            // Update data into the object store.\n            store.put(restaurant);\n          });\n      })\n      .catch(error => {\n        console.log(error);\n      });\n    };\n  };\n}\n\n/**\n * Function to handle offline request for a review.\n */\nfunction handleOfflineRequestForReview(reviewId) {\n  // Open a connection with indexedDB.\n  const request = s.indexedDB.open(`nyc_rr_data`, 1);\n\n  // Open a transaction and obtain a reference to the object store.\n  request.onsuccess = event => {\n    const db = event.target.result,\n          store = db.transaction(['reviews'], 'readonly').objectStore('reviews'),\n          request = store.get(reviewId); // Get data from indexedDB.\n\n    // Update database on network with fetch API.\n    request.onsuccess = event => {\n      let data = event.target.result;\n      delete data.id;\n      delete data.offline_request;\n\n      fetch(RESTAURANT_REVIEWS_URL, {\n        method: 'POST',\n        body: JSON.stringify(data),\n        headers: new Headers({\n          'Content-Type': 'application/json'\n        })\n      })\n      .then(() => {\n        fetch(`${RESTAURANT_REVIEWS_ID_URL}${data.restaurant_id}`)\n          .then(response => {\n            if (!response.ok) {\n              throw Error(`Request failed. Returned status of ${response.statusText}`);\n            }\n            return response.json();\n          })\n          .then(reviews => {\n            const store = db.transaction(['reviews'], 'readwrite').objectStore('reviews'),\n                  request = store.delete(reviewId);\n\n            request.onerror = event => {\n              console.log(event.target.error);\n            };\n\n            // Save data into the object store.\n            reviews.forEach(review => {\n              const store = db.transaction(['reviews'], 'readwrite').objectStore('reviews'),\n              request = store.put(review);\n\n              request.onerror = event => {\n                console.log(event.target.error);\n              };\n            });\n          });\n      })\n      .catch(error => {\n        console.log(error);\n      });\n    };\n  };\n}\n\n/**\n * Listen messages from client.\n */\ns.addEventListener('message', function(event) {\n  if (event.data.action === 'refresh') {\n    event.waitUntil(\n      s.skipWaiting() // Activate a new SW that is waiting.\n        .then(() => {\n          /* After receiving a message from one client, the new SW turns the message to all clients. */\n          sendMessageToClients('refreshed');\n        })\n        .catch(error => {\n          console.log('[SW] Something failed while skipping wait, error', error);\n        })\n    );\n  }\n  if (event.data.action === 'dismiss') {\n    event.waitUntil(\n      /* After receiving a message from one client, the current SW turns the message to all clients. */\n      sendMessageToClients('dismissed')\n    );\n  }\n\n  /* Listen for messages to handle forgotten offline requests for restaurants. */\n  if (event.data.action.indexOf('favorite-sync-') > -1) {\n    event.waitUntil(syncRestaurant(event.data.action));\n  }\n\n  /* Listen for messages to handle forgotten offline requests for reviews. */\n  if (event.data.action.indexOf('review-sync-') > -1) {\n    event.waitUntil(syncReview(event.data.action));\n  }\n});\n\n/**\n * Send a message to all clients.\n */\nfunction sendMessageToClients(message) {\n  /* Get a list of SW Client objects, and send a message to everyone. */\n  s.clients.matchAll()\n    .then(clients => {\n      clients.forEach(client => {\n        client.postMessage({action: message});\n      });\n    })\n    .catch(error => {\n      console.log('[SW] Something failed while sending message to clients, error', error);\n    });\n}\n})(self);\n"]}