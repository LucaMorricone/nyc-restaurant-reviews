{"version":3,"sources":["js/intersection-observer.js"],"names":["window","document","registry","IntersectionObserverEntry","entry","this","time","target","rootBounds","boundingClientRect","intersectionRect","top","IntersectionObserver","width","height","isIntersecting","targetRect","targetArea","intersectionArea","opt_options","fn","timeout","timer","options","callback","Error","root","_checkForIntersections","bind","THROTTLE_TIMEOUT","removeEvent","node","setTimeout","_callback","_observationTargets","_queuedEntries","_rootMarginValues","_parseRootMargin","rootMargin","thresholds","threshold","value","map","margin","unit","join","right","left","opt_useCapture","bottom","addEventListener","event","attachEvent","getBoundingClientRect","el","removeEventListener","detatchEvent","rect","err","getParentNode","containsDeep","parent","child","parentNode","nodeType","host","prototype","POLL_INTERVAL","USE_MUTATION_OBSERVER","observe","some","item","element","_registerInstance","push","_monitorIntersections","_unregisterInstance","filter","length","_unmonitorIntersections","disconnect","takeRecords","records","slice","_initThresholds","opt_threshold","Array","isArray","sort","t","i","a","isNaN","opt_rootMargin","margins","split","exec","parts","parseFloat","_monitoringIntersections","MutationObserver","characterData","subtree","setInterval","addEvent","_domObserver","attributes","clearInterval","_monitoringInterval","rootIsInDom","rootRect","_getRootRect","forEach","rootContainsTarget","_rootContainsTarget","oldEntry","_hasCrossedThreshold","_computeTargetAndRootIntersection","newEntry","performance","now","atRoot","getComputedStyle","display","rect1","rect2","parentRect","parentComputedStyle","body","documentElement","overflow","Math","min","getEmptyRect","clientWidth","html","newRect","clientHeight","_expandRectByRootMargin","oldRatio","newRatio","intersectionRatio","indexOf","index","splice"],"mappings":"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","file":"intersection-observer.js","sourcesContent":["/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.\n *\n *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\n *\n */\n\n(function(window, document) {\n'use strict';\n\n\n/**\n * An IntersectionObserver registry. This registry exists to hold a strong\n * reference to IntersectionObserver instances currently observering a target\n * element. Without this registry, instances without another reference may be\n * garbage collected.\n */\nvar registry = [];\n\n\n/**\n * Creates the global IntersectionObserverEntry constructor.\n * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\n * @param {Object} entry A dictionary of instance properties.\n * @constructor\n */\nfunction IntersectionObserverEntry(entry) {\n  this.time = entry.time;\n  this.target = entry.target;\n  this.rootBounds = entry.rootBounds;\n  this.boundingClientRect = entry.boundingClientRect;\n  this.intersectionRect = entry.intersectionRect || getEmptyRect();\n  this.isIntersecting = !!entry.intersectionRect;\n\n  // Calculates the intersection ratio.\n  var targetRect = this.boundingClientRect;\n  var targetArea = targetRect.width * targetRect.height;\n  var intersectionRect = this.intersectionRect;\n  var intersectionArea = intersectionRect.width * intersectionRect.height;\n\n  // Sets intersection ratio.\n  if (targetArea) {\n    this.intersectionRatio = intersectionArea / targetArea;\n  } else {\n    // If area is zero and is intersecting, sets to 1, otherwise to 0\n    this.intersectionRatio = this.isIntersecting ? 1 : 0;\n  }\n}\n\n\n/**\n * Creates the global IntersectionObserver constructor.\n * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n * @param {Function} callback The function to be invoked after intersection\n *     changes have queued. The function is not invoked if the queue has\n *     been emptied by calling the `takeRecords` method.\n * @param {Object=} opt_options Optional configuration options.\n * @constructor\n */\nfunction IntersectionObserver(callback, opt_options) {\n\n  var options = opt_options || {};\n\n  if (typeof callback != 'function') {\n    throw new Error('callback must be a function');\n  }\n\n  if (options.root && options.root.nodeType != 1) {\n    throw new Error('root must be an Element');\n  }\n\n  // Binds and throttles `this._checkForIntersections`.\n  this._checkForIntersections = throttle(\n      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);\n\n  // Private properties.\n  this._callback = callback;\n  this._observationTargets = [];\n  this._queuedEntries = [];\n  this._rootMarginValues = this._parseRootMargin(options.rootMargin);\n\n  // Public properties.\n  this.thresholds = this._initThresholds(options.threshold);\n  this.root = options.root || null;\n  this.rootMargin = this._rootMarginValues.map(function(margin) {\n    return margin.value + margin.unit;\n  }).join(' ');\n}\n\n\n/**\n * The minimum interval within which the document will be checked for\n * intersection changes.\n */\nIntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\n\n\n/**\n * The frequency in which the polyfill polls for intersection changes.\n * this can be updated on a per instance basis and must be set prior to\n * calling `observe` on the first target.\n */\nIntersectionObserver.prototype.POLL_INTERVAL = null;\n\n/**\n * Use a mutation observer on the root element\n * to detect intersection changes.\n */\nIntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;\n\n\n/**\n * Starts observing a target element for intersection changes based on\n * the thresholds values.\n * @param {Element} target The DOM element to observe.\n */\nIntersectionObserver.prototype.observe = function(target) {\n  var isTargetAlreadyObserved = this._observationTargets.some(function(item) {\n    return item.element == target;\n  });\n\n  if (isTargetAlreadyObserved) {\n    return;\n  }\n\n  if (!(target && target.nodeType == 1)) {\n    throw new Error('target must be an Element');\n  }\n\n  this._registerInstance();\n  this._observationTargets.push({element: target, entry: null});\n  this._monitorIntersections();\n  this._checkForIntersections();\n};\n\n\n/**\n * Stops observing a target element for intersection changes.\n * @param {Element} target The DOM element to observe.\n */\nIntersectionObserver.prototype.unobserve = function(target) {\n  this._observationTargets =\n      this._observationTargets.filter(function(item) {\n\n    return item.element != target;\n  });\n  if (!this._observationTargets.length) {\n    this._unmonitorIntersections();\n    this._unregisterInstance();\n  }\n};\n\n\n/**\n * Stops observing all target elements for intersection changes.\n */\nIntersectionObserver.prototype.disconnect = function() {\n  this._observationTargets = [];\n  this._unmonitorIntersections();\n  this._unregisterInstance();\n};\n\n\n/**\n * Returns any queue entries that have not yet been reported to the\n * callback and clears the queue. This can be used in conjunction with the\n * callback to obtain the absolute most up-to-date intersection information.\n * @return {Array} The currently queued entries.\n */\nIntersectionObserver.prototype.takeRecords = function() {\n  var records = this._queuedEntries.slice();\n  this._queuedEntries = [];\n  return records;\n};\n\n\n/**\n * Accepts the threshold value from the user configuration object and\n * returns a sorted array of unique threshold values. If a value is not\n * between 0 and 1 and error is thrown.\n * @private\n * @param {Array|number=} opt_threshold An optional threshold value or\n *     a list of threshold values, defaulting to [0].\n * @return {Array} A sorted list of unique and valid threshold values.\n */\nIntersectionObserver.prototype._initThresholds = function(opt_threshold) {\n  var threshold = opt_threshold || [0];\n  if (!Array.isArray(threshold)) threshold = [threshold];\n\n  return threshold.sort().filter(function(t, i, a) {\n    if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {\n      throw new Error('threshold must be a number between 0 and 1 inclusively');\n    }\n    return t !== a[i - 1];\n  });\n};\n\n\n/**\n * Accepts the rootMargin value from the user configuration object\n * and returns an array of the four margin values as an object containing\n * the value and unit properties. If any of the values are not properly\n * formatted or use a unit other than px or %, and error is thrown.\n * @private\n * @param {string=} opt_rootMargin An optional rootMargin value,\n *     defaulting to '0px'.\n * @return {Array<Object>} An array of margin objects with the keys\n *     value and unit.\n */\nIntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {\n  var marginString = opt_rootMargin || '0px';\n  var margins = marginString.split(/\\s+/).map(function(margin) {\n    var parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\n    if (!parts) {\n      throw new Error('rootMargin must be specified in pixels or percent');\n    }\n    return {value: parseFloat(parts[1]), unit: parts[2]};\n  });\n\n  // Handles shorthand.\n  margins[1] = margins[1] || margins[0];\n  margins[2] = margins[2] || margins[0];\n  margins[3] = margins[3] || margins[1];\n\n  return margins;\n};\n\n\n/**\n * Starts polling for intersection changes if the polling is not already\n * happening, and if the page's visibilty state is visible.\n * @private\n */\nIntersectionObserver.prototype._monitorIntersections = function() {\n  if (!this._monitoringIntersections) {\n    this._monitoringIntersections = true;\n\n    // If a poll interval is set, use polling instead of listening to\n    // resize and scroll events or DOM mutations.\n    if (this.POLL_INTERVAL) {\n      this._monitoringInterval = setInterval(\n          this._checkForIntersections, this.POLL_INTERVAL);\n    }\n    else {\n      addEvent(window, 'resize', this._checkForIntersections, true);\n      addEvent(document, 'scroll', this._checkForIntersections, true);\n\n      if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {\n        this._domObserver = new MutationObserver(this._checkForIntersections);\n        this._domObserver.observe(document, {\n          attributes: true,\n          childList: true,\n          characterData: true,\n          subtree: true\n        });\n      }\n    }\n  }\n};\n\n\n/**\n * Stops polling for intersection changes.\n * @private\n */\nIntersectionObserver.prototype._unmonitorIntersections = function() {\n  if (this._monitoringIntersections) {\n    this._monitoringIntersections = false;\n\n    clearInterval(this._monitoringInterval);\n    this._monitoringInterval = null;\n\n    removeEvent(window, 'resize', this._checkForIntersections, true);\n    removeEvent(document, 'scroll', this._checkForIntersections, true);\n\n    if (this._domObserver) {\n      this._domObserver.disconnect();\n      this._domObserver = null;\n    }\n  }\n};\n\n\n/**\n * Scans each observation target for intersection changes and adds them\n * to the internal entries queue. If new entries are found, it\n * schedules the callback to be invoked.\n * @private\n */\nIntersectionObserver.prototype._checkForIntersections = function() {\n  var rootIsInDom = this._rootIsInDom();\n  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\n\n  this._observationTargets.forEach(function(item) {\n    var target = item.element;\n    var targetRect = getBoundingClientRect(target);\n    var rootContainsTarget = this._rootContainsTarget(target);\n    var oldEntry = item.entry;\n    var intersectionRect = rootIsInDom && rootContainsTarget &&\n        this._computeTargetAndRootIntersection(target, rootRect);\n\n    var newEntry = item.entry = new IntersectionObserverEntry({\n      time: now(),\n      target: target,\n      boundingClientRect: targetRect,\n      rootBounds: rootRect,\n      intersectionRect: intersectionRect\n    });\n\n    if (!oldEntry) {\n      this._queuedEntries.push(newEntry);\n    } else if (rootIsInDom && rootContainsTarget) {\n      // If the new entry intersection ratio has crossed any of the\n      // thresholds, add a new entry.\n      if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n        this._queuedEntries.push(newEntry);\n      }\n    } else {\n      // If the root is not in the DOM or target is not contained within\n      // root but the previous entry for this target had an intersection,\n      // add a new record indicating removal.\n      if (oldEntry && oldEntry.isIntersecting) {\n        this._queuedEntries.push(newEntry);\n      }\n    }\n  }, this);\n\n  if (this._queuedEntries.length) {\n    this._callback(this.takeRecords(), this);\n  }\n};\n\n\n/**\n * Accepts a target and root rect computes the intersection between then\n * following the algorithm in the spec.\n * TODO(philipwalton): at this time clip-path is not considered.\n * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n * @param {Element} target The target DOM element\n * @param {Object} rootRect The bounding rect of the root after being\n *     expanded by the rootMargin value.\n * @return {?Object} The final intersection rect object or undefined if no\n *     intersection is found.\n * @private\n */\nIntersectionObserver.prototype._computeTargetAndRootIntersection =\n    function(target, rootRect) {\n\n  // If the element isn't displayed, an intersection can't happen.\n  if (window.getComputedStyle(target).display == 'none') return;\n\n  var targetRect = getBoundingClientRect(target);\n  var intersectionRect = targetRect;\n  var parent = getParentNode(target);\n  var atRoot = false;\n\n  while (!atRoot) {\n    var parentRect = null;\n    var parentComputedStyle = parent.nodeType == 1 ?\n        window.getComputedStyle(parent) : {};\n\n    // If the parent isn't displayed, an intersection can't happen.\n    if (parentComputedStyle.display == 'none') return;\n\n    if (parent == this.root || parent == document) {\n      atRoot = true;\n      parentRect = rootRect;\n    } else {\n      // If the element has a non-visible overflow, and it's not the <body>\n      // or <html> element, update the intersection rect.\n      // Note: <body> and <html> cannot be clipped to a rect that's not also\n      // the document rect, so no need to compute a new intersection.\n      if (parent != document.body &&\n          parent != document.documentElement &&\n          parentComputedStyle.overflow != 'visible') {\n        parentRect = getBoundingClientRect(parent);\n      }\n    }\n\n    // If either of the above conditionals set a new parentRect,\n    // calculate new intersection data.\n    if (parentRect) {\n      intersectionRect = computeRectIntersection(parentRect, intersectionRect);\n\n      if (!intersectionRect) break;\n    }\n    parent = getParentNode(parent);\n  }\n  return intersectionRect;\n};\n\n\n/**\n * Returns the root rect after being expanded by the rootMargin value.\n * @return {Object} The expanded root rect.\n * @private\n */\nIntersectionObserver.prototype._getRootRect = function() {\n  var rootRect;\n  if (this.root) {\n    rootRect = getBoundingClientRect(this.root);\n  } else {\n    // Use <html>/<body> instead of window since scroll bars affect size.\n    var html = document.documentElement;\n    var body = document.body;\n    rootRect = {\n      top: 0,\n      left: 0,\n      right: html.clientWidth || body.clientWidth,\n      width: html.clientWidth || body.clientWidth,\n      bottom: html.clientHeight || body.clientHeight,\n      height: html.clientHeight || body.clientHeight\n    };\n  }\n  return this._expandRectByRootMargin(rootRect);\n};\n\n\n/**\n * Accepts a rect and expands it by the rootMargin value.\n * @param {Object} rect The rect object to expand.\n * @return {Object} The expanded rect.\n * @private\n */\nIntersectionObserver.prototype._expandRectByRootMargin = function(rect) {\n  var margins = this._rootMarginValues.map(function(margin, i) {\n    return margin.unit == 'px' ? margin.value :\n        margin.value * (i % 2 ? rect.width : rect.height) / 100;\n  });\n  var newRect = {\n    top: rect.top - margins[0],\n    right: rect.right + margins[1],\n    bottom: rect.bottom + margins[2],\n    left: rect.left - margins[3]\n  };\n  newRect.width = newRect.right - newRect.left;\n  newRect.height = newRect.bottom - newRect.top;\n\n  return newRect;\n};\n\n\n/**\n * Accepts an old and new entry and returns true if at least one of the\n * threshold values has been crossed.\n * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n *    particular target element or null if no previous entry exists.\n * @param {IntersectionObserverEntry} newEntry The current entry for a\n *    particular target element.\n * @return {boolean} Returns true if a any threshold has been crossed.\n * @private\n */\nIntersectionObserver.prototype._hasCrossedThreshold =\n    function(oldEntry, newEntry) {\n\n  // To make comparing easier, an entry that has a ratio of 0\n  // but does not actually intersect is given a value of -1\n  var oldRatio = oldEntry && oldEntry.isIntersecting ?\n      oldEntry.intersectionRatio || 0 : -1;\n  var newRatio = newEntry.isIntersecting ?\n      newEntry.intersectionRatio || 0 : -1;\n\n  // Ignore unchanged ratios\n  if (oldRatio === newRatio) return;\n\n  for (var i = 0; i < this.thresholds.length; i++) {\n    var threshold = this.thresholds[i];\n\n    // Return true if an entry matches a threshold or if the new ratio\n    // and the old ratio are on the opposite sides of a threshold.\n    if (threshold == oldRatio || threshold == newRatio ||\n        threshold < oldRatio !== threshold < newRatio) {\n      return true;\n    }\n  }\n};\n\n\n/**\n * Returns whether or not the root element is an element and is in the DOM.\n * @return {boolean} True if the root element is an element and is in the DOM.\n * @private\n */\nIntersectionObserver.prototype._rootIsInDom = function() {\n  return !this.root || containsDeep(document, this.root);\n};\n\n\n/**\n * Returns whether or not the target element is a child of root.\n * @param {Element} target The target element to check.\n * @return {boolean} True if the target element is a child of root.\n * @private\n */\nIntersectionObserver.prototype._rootContainsTarget = function(target) {\n  return containsDeep(this.root || document, target);\n};\n\n\n/**\n * Adds the instance to the global IntersectionObserver registry if it isn't\n * already present.\n * @private\n */\nIntersectionObserver.prototype._registerInstance = function() {\n  if (registry.indexOf(this) < 0) {\n    registry.push(this);\n  }\n};\n\n\n/**\n * Removes the instance from the global IntersectionObserver registry.\n * @private\n */\nIntersectionObserver.prototype._unregisterInstance = function() {\n  var index = registry.indexOf(this);\n  if (index != -1) registry.splice(index, 1);\n};\n\n\n/**\n * Returns the result of the performance.now() method or null in browsers\n * that don't support the API.\n * @return {number} The elapsed time since the page was requested.\n */\nfunction now() {\n  return window.performance && performance.now && performance.now();\n}\n\n\n/**\n * Throttles a function and delays its executiong, so it's only called at most\n * once within a given time period.\n * @param {Function} fn The function to throttle.\n * @param {number} timeout The amount of time that must pass before the\n *     function can be called again.\n * @return {Function} The throttled function.\n */\nfunction throttle(fn, timeout) {\n  var timer = null;\n  return function () {\n    if (!timer) {\n      timer = setTimeout(function() {\n        fn();\n        timer = null;\n      }, timeout);\n    }\n  };\n}\n\n\n/**\n * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n * @param {Node} node The DOM node to add the event handler to.\n * @param {string} event The event name.\n * @param {Function} fn The event handler to add.\n * @param {boolean} opt_useCapture Optionally adds the even to the capture\n *     phase. Note: this only works in modern browsers.\n */\nfunction addEvent(node, event, fn, opt_useCapture) {\n  if (typeof node.addEventListener == 'function') {\n    node.addEventListener(event, fn, opt_useCapture || false);\n  }\n  else if (typeof node.attachEvent == 'function') {\n    node.attachEvent('on' + event, fn);\n  }\n}\n\n\n/**\n * Removes a previously added event handler from a DOM node.\n * @param {Node} node The DOM node to remove the event handler from.\n * @param {string} event The event name.\n * @param {Function} fn The event handler to remove.\n * @param {boolean} opt_useCapture If the event handler was added with this\n *     flag set to true, it should be set to true here in order to remove it.\n */\nfunction removeEvent(node, event, fn, opt_useCapture) {\n  if (typeof node.removeEventListener == 'function') {\n    node.removeEventListener(event, fn, opt_useCapture || false);\n  }\n  else if (typeof node.detatchEvent == 'function') {\n    node.detatchEvent('on' + event, fn);\n  }\n}\n\n\n/**\n * Returns the intersection between two rect objects.\n * @param {Object} rect1 The first rect.\n * @param {Object} rect2 The second rect.\n * @return {?Object} The intersection rect or undefined if no intersection\n *     is found.\n */\nfunction computeRectIntersection(rect1, rect2) {\n  var top = Math.max(rect1.top, rect2.top);\n  var bottom = Math.min(rect1.bottom, rect2.bottom);\n  var left = Math.max(rect1.left, rect2.left);\n  var right = Math.min(rect1.right, rect2.right);\n  var width = right - left;\n  var height = bottom - top;\n\n  return (width >= 0 && height >= 0) && {\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right,\n    width: width,\n    height: height\n  };\n}\n\n\n/**\n * Shims the native getBoundingClientRect for compatibility with older IE.\n * @param {Element} el The element whose bounding rect to get.\n * @return {Object} The (possibly shimmed) rect of the element.\n */\nfunction getBoundingClientRect(el) {\n  var rect;\n\n  try {\n    rect = el.getBoundingClientRect();\n  } catch (err) {\n    // Ignore Windows 7 IE11 \"Unspecified error\"\n    // https://github.com/w3c/IntersectionObserver/pull/205\n  }\n\n  if (!rect) return getEmptyRect();\n\n  // Older IE\n  if (!(rect.width && rect.height)) {\n    rect = {\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      width: rect.right - rect.left,\n      height: rect.bottom - rect.top\n    };\n  }\n  return rect;\n}\n\n\n/**\n * Returns an empty rect object. An empty rect is returned when an element\n * is not in the DOM.\n * @return {Object} The empty rect.\n */\nfunction getEmptyRect() {\n  return {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n    width: 0,\n    height: 0\n  };\n}\n\n/**\n * Checks to see if a parent element contains a child elemnt (including inside\n * shadow DOM).\n * @param {Node} parent The parent element.\n * @param {Node} child The child element.\n * @return {boolean} True if the parent node contains the child node.\n */\nfunction containsDeep(parent, child) {\n  var node = child;\n  while (node) {\n    if (node == parent) return true;\n\n    node = getParentNode(node);\n  }\n  return false;\n}\n\n\n/**\n * Gets the parent node of an element or its host element if the parent node\n * is a shadow root.\n * @param {Node} node The node whose parent to get.\n * @return {Node|null} The parent node or null if no parent exists.\n */\nfunction getParentNode(node) {\n  var parent = node.parentNode;\n\n  if (parent && parent.nodeType == 11 && parent.host) {\n    // If the parent is a shadow root, return the host element.\n    return parent.host;\n  }\n  return parent;\n}\n\n\n// Exposes the constructors globally.\nwindow.IntersectionObserver = IntersectionObserver;\nwindow.IntersectionObserverEntry = IntersectionObserverEntry;\n\n}(window, document));\n"]}