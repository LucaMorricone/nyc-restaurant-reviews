{"version":3,"sources":["sw.js"],"names":["s","ORIGIN","STATIC_CACHE","DYNAMIC_CACHE","RESOURCES_TO_CACHE","addEventListener","event","sendMessageToClients","message","clients","matchAll","then","forEach","client","postMessage","action","catch","error","console","log","waitUntil","Promise","all","cacheNames","cacheName","map","caches","keys","filter","startsWith","request","indexOf","claim","response","url","location","origin","match","respondWith","open","cache","fetch","skipWaiting","status","put","clone","data","self"],"mappings":"cAAA,SAAEA,GAAD,IACCC,EAAA,UAGEC,EAAkBD,EAAlB,kBAFFE,EAAAF,EAAA,mBAAAG,EAAA,CAEEF,IACAC,cACAC,mBAYE,kBACA,cAPA,kBAUJ,eARI,yBACA,6BAUFC,YACAC,gBACE,gBAmHJ,SAASC,EAAqBC,GAE5BR,EAAES,QAAQC,WACPC,KAAK,SAAAF,GACJA,EAAQG,QAAQ,SAAAC,GACdA,EAAOC,YAAY,CAACC,OAAQP,QAG/BQ,MAAM,SAAAC,GACLC,QAAQC,IAAI,gEAAiEF,KA9HnFjB,EAAEK,iBAAiB,UAAW,SAAAC,GAC5BA,EAAMc,UAcNf,OAAAA,KAAAA,GACAC,KAAMc,SAAAA,GAGA,OAAOC,EAAQC,OACbC,KAEEP,MAAQQ,SAAAA,GACPC,QAAIN,IAAA,mCAAaF,QAWvBjB,EAAAK,iBAlBL,WAAA,SAAAC,GADFA,EAAAc,UAEIM,OAAOC,OAqBXhB,KAAA,SAAAY,GAnBQ,OAAOF,QAAQC,IACbC,EAAWK,OAAO,SAAAJ,GAsB1B,OAAAA,EAAAK,WAAA5B,IAAAuB,IAAAtB,GAAAsB,IAAArB,IACU2B,IAAAA,SAAAA,GACJxB,OAAMwB,OAAYC,OAAlBP,QAMDb,KAAA,WANH,OAUOX,EAAAS,QAAAuB,UAIChB,MAAIiB,SAAAA,GACJf,QAAOQ,IAAAA,iCACCT,QAUGjB,EAAAK,iBAJH,QAAA,SAAAC,GAMD,GAAAA,EAXIwB,QAYEI,IAAAL,WAAA7B,EAASmC,SAAAC,QACdlB,IAAY,EAAZA,EAAAA,QAAQC,IAAIY,QAAA,mBAAZ,CACA,IAAA,IAAAzB,EAAAwB,QAAOJ,IAAOW,OAAM,QAKzB,YAJI/B,EAfHgC,YAFGZ,OAmBEW,MAAA,cAKTnB,EAAAA,YA5BNQ,OAAAW,MAAA,0BAdN/B,EAAAgC,YAeQZ,OAAOW,MAAM/B,EAAMwB,SAkC3BnB,KAAA,SAAAsB,GAhCY,OAAIA,GACGP,OAAOa,KAAKpC,GAkC7BE,KAAiB,SAAAmC,GACb,OAAAC,MAAsBnC,EAAAwB,SACxBnB,KACI+B,SAAAA,GACM,OAAM,MAAAT,EAAAU,OACVjB,OAAAW,MAAA,cAGKG,EAAAI,IAAStC,EAAAwB,QAAAG,EAAAY,SACF7B,MAAA,SAAAC,GAGnBC,QAAAC,IAAA,qCAAAF,EAAAX,EAAAwB,QAAAI,OAECD,KAEE1B,MAAqB,SAAAU,GAhB3B,OAkBGC,QAAAC,IAAA,mCAAAF,GAlBHS,OAAAW,MAAA,qBAferB,MAAM,SAAAC,GACLC,QAAQC,IAAI,2CAA4CF,OAwCtED,MAAUN,SAAAA,GAEEE,QAAQO,IAAA,wDAAUF,QA5BhCjB,EAAEK,iBAAiB,UAAW,SAASC,GACX,YAAtBA,EAAMwC,KAAK/B,QACbT,EAAMc,UACJpB,EAAE0C,cACC/B,KAAK,WAEJJ,EAAqB,eAEtBS,MAAM,SAAAC,GACLC,QAAQC,IAAI,mDAAoDF,MAI9C,YAAtBX,EAAMwC,KAAK/B,QACbT,EAAMc,UAEJb,EAAqB,gBAtI7B,CA0JGwC","file":"sw.js","sourcesContent":["((s) => {\n  'use strict';\n  const SW_VERSION = 1,\n    ORIGIN = 'NYC-RR-',\n    STATIC_CACHE = `${ORIGIN}static-cache-v${SW_VERSION}`,\n    DYNAMIC_CACHE = `${ORIGIN}dynamic-cache-v${SW_VERSION}`,\n    RESOURCES_TO_CACHE = [\n      '/',\n      '/index.html',\n      '/restaurant.html',\n      '/css/styles.css',\n      '/js/main.js',\n      '/js/dbhelper.js',\n      '/js/index.js',\n      '/js/restaurant_info.js',\n      '/img/image-placeholder.svg',\n      '/404.html',\n      '/offline.html',\n      /* Unfortunally Service Worker 'fetch' event does not trigger for favicons in Chrome. This bug is still open. https://bugs.chromium.org/p/chromium/issues/detail?id=448427 */\n      '/favicon.ico'\n  ];\n\n  /**\n   * Cache the main assets while installing SW.\n   */\n  s.addEventListener('install', event => {\n    event.waitUntil(\n      caches.open(STATIC_CACHE)\n        .then(cache => {\n          return cache.addAll(RESOURCES_TO_CACHE);\n        })\n        .catch(error => {\n          console.log('[SW] Installation failed, error:', error);\n        })\n    );\n  });\n\n  /**\n   * Remove outdated caches while a new SW is activating.\n   */\n  s.addEventListener('activate', event => {\n    event.waitUntil(\n      caches.keys()\n        .then(cacheNames => {\n          return Promise.all(\n            cacheNames.filter(cacheName => {\n              // Caches are shared across the whole origin.\n              return (cacheName.startsWith(ORIGIN) && cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE);\n            }).map(cacheName => {\n              return caches.delete(cacheName);\n            })\n          );\n        })\n        .then(() => {\n          /* Allow the active service worker to set itself as the controller for all clients within its scope. This triggers a \"controllerchange\" event on navigator.serviceWorker in any clients that become controlled by this service worker. https://developer.mozilla.org/en-US/docs/Web/API/Clients/claim */\n          return s.clients.claim();\n        })\n        .catch(error => {\n          console.log('[SW] Activation failed, error:', error);\n        })\n    );\n  });\n\n  /**\n   * Cache other resources dynamically with a fallback to the network.\n   */\n  s.addEventListener('fetch', event => {\n    /* The fetch handler serves responses only for same-origin resources. */\n    if (event.request.url.startsWith(s.location.origin)) {\n      if (event.request.url.indexOf('restaurant.html') > -1) {\n        if (event.request.url.search(/id=./) === -1) {\n          event.respondWith(\n            caches.match('/404.html')\n          );\n          return;\n        }\n        event.respondWith(\n          caches.match('/restaurant.html')\n        );\n      } else {\n        event.respondWith(\n          caches.match(event.request)\n            .then(response => {\n              if (response) return response;\n              return caches.open(DYNAMIC_CACHE)\n                .then(cache => {\n                  return fetch(event.request)\n                    .then(response => {\n                      if (response.status === 404) {\n                        return caches.match('/404.html');\n                      }\n                      cache.put(event.request, response.clone())\n                        .catch(error => {\n                          /* In some cases dynamic caching fails: e.g. it's not possible to cache a resource because a \"DOMException: Quota exceeded\" error fires. */\n                          console.log('[SW] Dynamic caching failed, error', error, event.request.url);\n                        });\n                      return response;\n                    })\n                    .catch(error => {\n                      console.log('[SW] Fetch request failed, error', error);\n                      return caches.match('/offline.html');\n                    });\n                })\n                .catch(error => {\n                  console.log('[SW] Opening dynamic cache failed, error', error);\n                });\n            })\n            .catch(error => {\n              console.log('[SW] Something failed while matching a request, error', error);\n            })\n        );\n      }\n    }\n  });\n\n  /**\n   * Listen messages from client.\n   */\n  s.addEventListener('message', function(event) {\n    if (event.data.action === 'refresh') {\n      event.waitUntil(\n        s.skipWaiting() // Activate a new SW that is waiting.\n          .then(() => {\n            /* After receiving a message from one client, the new SW turns the message to all clients. */\n            sendMessageToClients('refreshed');\n          })\n          .catch(error => {\n            console.log('[SW] Something failed while skipping wait, error', error);\n          })\n      );\n    }\n    if (event.data.action === 'dismiss') {\n      event.waitUntil(\n        /* After receiving a message from one client, the current SW turns the message to all clients. */\n        sendMessageToClients('dismissed')\n      );\n    }\n  });\n\n  /**\n   * Send a message to all clients.\n   */\n  function sendMessageToClients(message) {\n    /* Get a list of SW Client objects, and send a message to everyone. */\n    s.clients.matchAll()\n      .then(clients => {\n        clients.forEach(client => {\n          client.postMessage({action: message});\n        });\n      })\n      .catch(error => {\n        console.log('[SW] Something failed while sending message to clients, error', error);\n      });\n  }\n})(self);"]}