{"version":3,"sources":["js/app.js"],"names":["w","d","n","fetch","ClientError","gEBI","getElementById","cE","createElement","IntersectionObserver","IntersectionObserverEntry","prototype","Object","defineProperty","addAsyncScript","get","this","intersectionRatio","code","message","_classCallCheck","RESTAURANTS_URL","RESTAURANT_REVIEWS_URL","port","staticMap","map","tilesLoaded","mapOnFilter","onReady","callback","readyState","addEventListener","f","article","append","ratingContainer","li","appendChild","request","indexedDB","open","onupgradeneeded","event","catch","db","target","result","createObjectStore","keyPath","createIndex","unique","Promise","resolve","onsuccess","store","transaction","itemsString","objectStore","index","range","restaurantId","IDBKeyRange","only","cursor","IDBItems","length","push","response","json","onLine","value","offline_request","Error","serviceWorker","SyncManager","controller","postMessage","action","id","handleForgottenOfflineRequests","continue","console","url","statusText","indexOrStore","openCursor","items","error","onerror","onlyFetchItems","then","log","sw","sync","register","data","updateFavoriteOnline","saveFavoriteOnIndexedDB","is_favorite","method","idbData","offlineRequest","saveReviewOnIndexedDB","updateReviewOnline","Math","random","toString","substr","mapMarkerForRestaurant","restaurant","google","maps","Marker","position","latlng","title","neighborhood","marker","name","urlForRestaurant","imageUrlForRestaurant","width","photograph","src","script","setAttribute","head","initStaticMap","doit","setTimeout","clearTimeout","getResponsiveStaticMapParameters","clientWidth","height","clientHeight","aspectRatio","toFixed","scale","round","lazyLoadStaticMap","blob","backgroundImage","URL","createObjectURL","images","style","addListenerToStaticMap","actionOnMap","addListenerTo","element","remove","preventDefault","removeEventListener","keyCode","display","removeAttribute","swapMap","showOfflineAlert","button","offlineAlert","paragraphAlert","innerHTML","close","type","p","opacity","addClickListenerToMarker","addListener","location","href","overlay","OverlayView","draw","getPanes","initMapA11y","isIndex","skipMap","divWithTabindex","mapDOMElement","querySelector","className","addA11yToMap","firstChild","mapLabel","insertBefore","add","setOptions","keyboardShortcuts","listenerTiles","focus","addA11yToMarkers","currentRestaurants","areas","querySelectorAll","_loop","i","tabIndex","layers","addImageOfTo","parent","image","alt","photoDescription","cuisine_type","jpg","webp","dataset","srcset","srcsetStr","formatSrcset","join","replace","sizes","picture","lazyLoad","lazyImages","slice","call","observer","entries","forEach","entry","isIntersecting","parentElement","children","fetchItems","restaurants","pathname","markers","nSelect","getCurrentRestaurants","selectedIndex","cuisine","cSelect","results","filter","r","addMarkersAndA11y","s","updateRestaurants","option","m","setMap","updateMarkers","rList","resetMarkers","addRestaurantsHTML","notice","address","label","favorite","updateRestaurantsHTML","fillRestaurantHTML","strong","addressContent","more","checked","params","neighborhoods","v","indexOf","cuisines","addSelectListener","initMap","Map","lat","loc","center","zoom","scrollwheel","searchParams","review","container","reviews","noReviews","rating","comments","updatedAt","date","theDate","Date","header","toISOString","heading","toLocaleDateString","year","month","createRestaurantReviewHTML","sending","day","breadcrumb","a","lng","addReviewButton","username","getElementsByName","closeOverlayButton","page","focusableElementsString","fillRestaurantInfoHTML","card","form","operatingHours","hours","time","key","scope","row","fillRestaurantHoursHTML","operating_hours","tabindexZeroElements","formElements","onESC","classList","closeOverlay","stopPropagation","parseInt","rate","reviewId","ready","addReview","body","JSON","stringify","headers","Headers","Content-Type","restaurant_id","ok","ul","reset","focusableElements","onSubmit","RESTAURANT_REVIEWS_ID_URL","online","lastChild","reverse","window","document","navigator"],"mappings":"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","file":"app.js","sourcesContent":["((w, d, n) => {\n'use strict';\n\nif (!w.fetch) { // Check fetch API support.\n  throw new ClientError(400, 'Fetch API Not Supported');\n}\n\n// Create useful alias of native functions.\nd.gEBI = d.getElementById;\nd.cE = d.createElement;\n\n/**\n * Check IntersectionObserver and IntersectionObserverEntry features support.\n */\nif (!(w.IntersectionObserver && w.IntersectionObserverEntry &&\n'intersectionRatio' in w.IntersectionObserverEntry.prototype)) {\n  // If not supported load polyfill.\n  addAsyncScript('js/intersection-observer.js');\n} else if (!('isIntersecting' in w.IntersectionObserverEntry.prototype)) {\n  /* Minimal polyfill for Edge 15's lack of `isIntersecting`. See: https://github.com/w3c/IntersectionObserver/issues/211 */\n  Object.defineProperty(w.IntersectionObserverEntry.prototype,\n    'isIntersecting', {\n    get: function () {\n      return this.intersectionRatio > 0;\n    }\n  });\n}\n\nclass ClientError {\n  constructor(code, message) {\n    this.code = code;\n    this.message = message;\n  }\n}\n\nconst port = 1337,\n      RESTAURANTS_URL = `http://localhost:${port}/restaurants`,\n      RESTAURANT_REVIEWS_URL = `http://localhost:${port}/reviews`,\n      RESTAURANT_REVIEWS_ID_URL = `${RESTAURANT_REVIEWS_URL}/?restaurant_id=`;\n\n\nlet staticMap,\n    map,\n    tilesLoaded,\n    mapOnFilter;\n\n/**\n * Catch DOMContentLoaded event even the script is loading asynchronously.\n */\nfunction onReady(callback) {\n  d.readyState !== 'loading' ? callback() : d.addEventListener('DOMContentLoaded', function f() {\n    callback();\n    d.removeEventListener('DOMContentLoaded', f);\n  });\n}\n\n/**\n * MAIN PROCESS.\n */\nfetchItems('restaurants', RESTAURANTS_URL)\n  .then(restaurants => {\n    if (w.location.pathname === '/' || w.location.pathname === '/index.html') { // === HOME - index.html ===\n      (() => {\n        // Some useful variables declarations or initializations.\n        let markers = [],\n            nSelect,\n            cSelect,\n            rList;\n\n        onReady(() => {\n          // Some useful variables initializations.\n          staticMap = d.gEBI('static-map'),\n          nSelect = d.gEBI('neighborhoods-select'),\n          cSelect = d.gEBI('cuisines-select'),\n          rList = d.gEBI('restaurants-list');\n\n          if (n.onLine) { // With Internet connection.\n            initStaticMap(() => {\n              setStaticMap(getResponsiveStaticMapParameters());\n            });\n            addListenerToStaticMap();\n          } else { // Offline.\n            showOfflineAlert();\n          }\n          addSelectListener();\n          addRestaurantsHTML(restaurants);\n          lazyLoad();\n        });\n\n        function setStaticMap(params) {\n          lazyLoadStaticMap(`https://maps.googleapis.com/maps/api/staticmap?center=40.722216,-73.987501&zoom=12&size=${params.width}x${params.height}&scale=${params.scale}&format=jpg&key=AIzaSyAxfOOcB40yMKfupF4qyfa4hwvhTclZboA`);\n        }\n\n        /**\n         * Initialize Google Maps.\n         */\n        w.initMap = () => {\n          let loc = {\n            lat: 40.722216,\n            lng: -73.987501\n          };\n\n          map = new google.maps.Map(d.gEBI('map'), {\n            center: loc,\n            zoom: 12,\n            scrollwheel: false,\n            keyboardShortcuts: false // Disable Google Maps keyboard UI.\n          });\n\n          getCurrentRestaurants()\n            .then(currentRestaurants => {\n              addMarkersAndA11y(currentRestaurants);\n            });\n        };\n\n        /**\n         * Get current restaurants by a cuisine and a neighborhood.\n         */\n        function getCurrentRestaurants() {\n          return new Promise(resolve => {\n            const neighborhood = nSelect[nSelect.selectedIndex].value,\n                  cuisine = cSelect[cSelect.selectedIndex].value;\n\n            let results = restaurants.slice(0);\n            if (cuisine != 'all') { // Filter by cuisine.\n              results = results.filter(r => r.cuisine_type === cuisine);\n            }\n            if (neighborhood != 'all') { // Filter by neighborhood.\n              results = results.filter(r => r.neighborhood === neighborhood);\n            }\n            resolve(results);\n          });\n        }\n\n        /**\n         * Add map markers for current restaurants.\n         */\n        function addMarkersAndA11y(currentRestaurants) {\n          currentRestaurants.forEach(restaurant => {\n            // Add marker to the map.\n            const marker = mapMarkerForRestaurant(restaurant, map);\n\n            addClickListenerToMarker(marker);\n\n            markers.push(marker);\n          });\n\n          initMapA11y(() => {\n            addA11yToMarkers(null, currentRestaurants, () => {\n              const s = (currentRestaurants.length > 1) ? 's' : '';\n              /* Relying on the title attribute is currently discouraged as many user agents do not expose the attribute in an accessible manner as required by w3c specifications. https://www.w3.org/TR/html/dom.html#the-title-attribute */\n              /* However, many sources say that <iframe> elements in the document must have a title that is not empty to describe their contents to screen reader users. https://dequeuniversity.com/rules/axe/2.2/frame-title */\n              d.querySelector('#map iframe').title = `Map shows ${currentRestaurants.length} restaurant${s}`;\n            });\n          }, true);\n        }\n\n        /**\n         * Add event listener on select elements to filter results.\n         */\n        function addSelectListener() {\n          nSelect.addEventListener('change', updateRestaurants);\n          cSelect.addEventListener('change', updateRestaurants);\n\n          // Get all neighborhoods from all restaurants.\n          let neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood);\n\n          // Remove duplicates from neighborhoods.\n          neighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) === i);\n\n          // Set neighborhoods HTML.\n          neighborhoods.forEach(neighborhood => {\n            const option = d.cE('option');\n            option.innerHTML = neighborhood;\n            option.value = neighborhood;\n            nSelect.appendChild(option);\n          });\n\n          // Get all cuisines from all restaurants.\n          let cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type);\n\n          // Remove duplicates from cuisines.\n          cuisines = cuisines.filter((v, i) => cuisines.indexOf(v) === i);\n\n          // Set cuisines HTML.\n          cuisines.forEach(cuisine => {\n            const option = d.cE('option');\n            option.innerHTML = cuisine;\n            option.value = cuisine;\n            cSelect.appendChild(option);\n          });\n        }\n\n        /**\n         * Update page and map markers with current restaurants.\n         */\n        function updateRestaurants() {\n          getCurrentRestaurants()\n            .then(currentRestaurants => {\n              // Update markers only if Google Maps was initialized.\n              if (map) updateMarkers(currentRestaurants);\n              updateRestaurantsHTML(currentRestaurants);\n              lazyLoad();\n            });\n\n          // Load map if it is not loaded yet.\n          if (staticMap && !map) {\n            mapOnFilter = true;\n            actionOnMap();\n          }\n        }\n\n        /**\n         * Update restaurants map markers.\n         */\n        function updateMarkers(currentRestaurants) {\n          resetMarkers();\n          addMarkersAndA11y(currentRestaurants);\n        }\n\n        /**\n         * Remove restaurants map markers.\n         */\n        function resetMarkers() {\n          // If offline, markers could be not initialized.\n          if (markers.length) {\n            /* Remove all map markers. When a DOM Element is removed, its listeners are removed from memory too. */\n            markers.forEach(m => m.setMap(null));\n            markers = [];\n          }\n        }\n\n        /**\n         * Update current restaurants HTML.\n         */\n        function updateRestaurantsHTML(currentRestaurants) {\n          rList.innerHTML = ''; // Remove all restaurants.\n\n          addRestaurantsHTML(currentRestaurants);\n        }\n\n        /**\n         * Create all restaurants HTML and add them to the webpage.\n         */\n        function addRestaurantsHTML(currentRestaurants) {\n          const notice = d.gEBI('results-notice');\n          if (!currentRestaurants.length) {\n            notice.innerHTML = 'No restaurants found';\n          } else {\n            currentRestaurants.forEach(restaurant => {\n              rList.appendChild(fillRestaurantHTML(restaurant));\n            });\n            let s = (currentRestaurants.length > 1) ? 's' : '';\n            notice.innerHTML = `${currentRestaurants.length} restaurant${s} found`;\n          }\n        }\n\n        /**\n         * Create restaurant HTML.\n         */\n        function fillRestaurantHTML(restaurant) {\n          const li = d.cE('li'),\n                article = d.cE('article'),\n                name = d.cE('h3'),\n                neighborhood = d.cE('p'),\n                strong = d.cE('strong'),\n                address = d.cE('address'),\n                addressContent = d.cE('p'),\n                more = d.cE('p'),\n                label = d.cE('label'),\n                favorite = d.cE('input'),\n                button = d.cE('a');\n\n          addImageOfTo(restaurant, article, true);\n\n          name.innerHTML = restaurant.name;\n\n          strong.innerHTML = `${restaurant.neighborhood}`;\n          neighborhood.appendChild(strong);\n\n          addressContent.innerHTML = restaurant.address;\n          address.appendChild(addressContent);\n\n          favorite.type = 'checkbox';\n          favorite.id = `favorite-${restaurant.id}`;\n          /* Normally we should write \"favorite.checked = restaurant.is_favorite;\" but there is a bug in the server of stage 3. Favourites endpoints writes incorrectly: the value becomes a string instead a boolean. So we must use a workaround. See: https://github.com/udacity/mws-restaurant-stage-3/issues/5 */\n          favorite.checked = (restaurant.is_favorite === 'false') ? false : (restaurant.is_favorite === 'true') ? true : restaurant.is_favorite;\n          favorite.className = 'button';\n\n          favorite.addEventListener('click', () => {\n            setFavorite({\n              id: restaurant.id,\n              is_favorite: favorite.checked\n            });\n          });\n\n          label.htmlFor = favorite.id;\n          label.className = 'sr-only';\n          label.innerHTML = `Is ${restaurant.name} your favorite restaurant?`;\n\n          button.innerHTML = 'View Details';\n          button.href = urlForRestaurant(restaurant);\n          button.className = 'button';\n          /* Relying on the title attribute is currently discouraged as many user agents do not expose the attribute in an accessible manner as required by w3c specifications. https://www.w3.org/TR/html/dom.html#the-title-attribute */\n          /* The only very tiny exception a title attribute will be read by a screen reader is if there's absolutely no link anchor text. https://silktide.com/i-thought-title-text-improved-accessibility-i-was-wrong/ */\n          /*  One alternative option could be using aria-labelledby, but in this case it's better using the aria-label attribute instead of title. N.B. The aria-label overrides the link text. */\n          button.setAttribute('aria-label', `View Details about ${restaurant.name}`);\n          more.append(label, favorite, button);\n\n          article.append(name, neighborhood, address, more);\n\n          li.appendChild(article);\n          return li;\n        }\n      })();\n    } else { // === RESTAURANT - restaurant.html ===\n      (() => {\n        // Get current restaurant from page URL.\n        const restaurant = (() => {\n          const id = new URL(w.location.href).searchParams.get('id');\n          if (!id || !restaurants[id - 1]) return; // Exit from function.\n          return restaurants[id - 1];\n        })();\n\n        if (!restaurant) {\n          throw new ClientError(404, 'File Not Found');\n        }\n\n        onReady(() => {\n          staticMap = d.gEBI('static-map');\n\n          if (n.onLine) { // With Internet connection.\n            initStaticMap(() => {\n              setStaticMap(getResponsiveStaticMapParameters());\n            });\n            addListenerToStaticMap();\n          } else { // Offline.\n            showOfflineAlert();\n          }\n          fillBreadcrumb(restaurant);\n          fillRestaurantInfoHTML(restaurant);\n          lazyLoad();\n        });\n\n        function setStaticMap(params) {\n          lazyLoadStaticMap(`https://maps.googleapis.com/maps/api/staticmap?size=${params.width}x${params.height}&scale=${params.scale}&markers=color:red%7C${restaurant.latlng.lat},${restaurant.latlng.lng}&format=jpg&key=AIzaSyAxfOOcB40yMKfupF4qyfa4hwvhTclZboA`);\n        }\n\n        /**\n         * Initialize Google Maps, called from HTML.\n         */\n        w.initMap = () => {\n          map = new google.maps.Map(d.gEBI('map'), {\n            center: restaurant.latlng,\n            zoom: 17,\n            scrollwheel: false,\n            keyboardShortcuts: false // Disable Google Maps keyboard UI.\n          });\n          // Add marker to the map.\n          const marker = mapMarkerForRestaurant(restaurant, map);\n\n          addClickListenerToMarker(marker);\n\n          initMapA11y(() => {\n            addA11yToMarkers(restaurant, null, () => {\n              /* Relying on the title attribute is currently discouraged as many user agents do not expose the attribute in an accessible manner as required by w3c specifications. https://www.w3.org/TR/html/dom.html#the-title-attribute */\n              /* However, many sources say that <iframe> elements in the document must have a title that is not empty to describe their contents to screen reader users. https://dequeuniversity.com/rules/axe/2.2/frame-title */\n              d.querySelector('#map iframe').title = `Map shows ${restaurant.name} location`;\n            });\n          });\n        };\n\n        /**\n         * Add restaurant name to the breadcrumb navigation menu.\n         */\n        function fillBreadcrumb(restaurant) {\n          const breadcrumb = d.gEBI('breadcrumb'),\n                li = d.cE('li'),\n                a = d.cE('a'),\n                url = urlForRestaurant(restaurant);\n\n          a.href = url;\n          /* Here the title attribute is to avoid, and the link text is enough for accessibility. See above about title. */\n          a.setAttribute('aria-current', 'page' );\n          a.innerHTML = restaurant.name;\n\n          li.appendChild(a);\n          breadcrumb.appendChild(li);\n        }\n\n        /**\n         * Create restaurant HTML and add it to the webpage.\n         */\n        function fillRestaurantInfoHTML(restaurant) {\n          const card = d.querySelector('#restaurant-container> div'),\n                name = d.gEBI('restaurant-name'),\n                address = d.gEBI('restaurant-address'),\n                cuisine = d.gEBI('restaurant-cuisine'),\n                strong = d.cE('strong'),\n                favorite = d.gEBI('favorite'),\n                addReviewButton = d.gEBI('add-review-button'),\n                overlay = d.gEBI('overlay'),\n                form = d.querySelector('#overlay form'),\n                username = d.gEBI('username'),\n                rating = [].slice.call(d.getElementsByName('rating')),\n                comments = d.gEBI('comments'),\n                closeOverlayButton = d.gEBI('close-overlay-button'),\n                page = d.gEBI('page'),\n                focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');\n\n          // Add a more meaningful title to the page for better accessibility.\n          d.title = `${restaurant.name} - Restaurant Info and Reviews`;\n\n          addImageOfTo(restaurant, card);\n\n          name.innerHTML = restaurant.name;\n\n          address.innerHTML = restaurant.address;\n\n          strong.innerHTML = `Type of Cuisine: ${restaurant.cuisine_type}`;\n          cuisine.appendChild(strong);\n\n          // Fill restaurant operating hours.\n          if (restaurant.operating_hours) {\n            fillRestaurantHoursHTML(restaurant.operating_hours);\n          }\n\n          /* Normally we should write \"favorite.checked = restaurant.is_favorite;\" but there is a bug in the server of stage 3. Favourites endpoints writes incorrectly: the value becomes a string instead a boolean. So we must use a workaround. See: https://github.com/udacity/mws-restaurant-stage-3/issues/5 */\n          favorite.checked = (restaurant.is_favorite === 'false') ? false : (restaurant.is_favorite === 'true') ? true : restaurant.is_favorite;\n\n          favorite.addEventListener('click', () => {\n            setFavorite({\n              id: restaurant.id,\n              is_favorite: favorite.checked\n            });\n          });\n\n          addReviewButton.addEventListener('click', () => {\n            const focusableElements = [].slice.call(page.querySelectorAll(focusableElementsString));\n            const tabindexZeroElements = [].slice.call(page.querySelectorAll('[tabindex=\"0\"]'));\n            const formElements = [].slice.call(overlay.querySelectorAll('[tabindex=\"-1\"]'));\n\n            // Open overlay.\n            focusableElements.forEach((element) => {\n              element.tabIndex = -1;\n            });\n\n            tabindexZeroElements.forEach((element) => {\n              element.tabIndex = -1;\n            });\n\n            formElements.forEach((element) => {\n              element.tabIndex = 0;\n            });\n\n            overlay.removeAttribute('aria-hidden');\n            overlay.classList.add('opened');\n            page.setAttribute('aria-hidden', true);\n\n            // Move focus to first input text.\n            username.focus();\n\n            // Add event listener to close button.\n            closeOverlayButton.addEventListener('click', closeOverlay);\n\n            // Add event listener to close overlay on press ESC.\n            d.addEventListener('keydown', onESC);\n\n            form.addEventListener('submit', onSubmit);\n\n            // Close overlay on press ESC.\n            function onESC(event) {\n              if (event.keyCode === 27) {\n                event.preventDefault();\n                event.stopPropagation();\n                closeOverlay();\n                closeOverlayButton.removeEventListener('click', closeOverlay);\n              }\n            }\n\n            // Add review and close overlay on submit.\n            function onSubmit(event) {\n              event.preventDefault();\n              event.stopPropagation();\n\n              const data = {\n                restaurant_id: restaurant.id,\n                name: username.value,\n                rating: parseInt(rating.filter(rate => rate.checked === true)[0].value),\n                comments: comments.value\n              };\n\n              addReview(data);\n\n              const ul = d.gEBI('reviews-list');\n              ul.insertBefore(createRestaurantReviewHTML(data), ul.firstChild);\n\n              form.reset();\n              closeOverlay();\n            }\n\n            // Close overlay function.\n            function closeOverlay() {\n              focusableElements.forEach((element) => {\n                element.removeAttribute('tabindex');\n              });\n\n              tabindexZeroElements.forEach((element) => {\n                element.tabIndex = 0;\n              });\n\n              formElements.forEach((element) => {\n                element.tabIndex = -1;\n              });\n\n              page.removeAttribute('aria-hidden');\n              overlay.classList.remove('opened');\n              overlay.setAttribute('aria-hidden', true);\n\n              // Move focus to add review button.\n              addReviewButton.focus();\n\n              // Remove event listener on keydown and on submit.\n              d.removeEventListener('keydown', onESC);\n              form.removeEventListener('onsubmit', onSubmit);\n            }\n          });\n\n          fetchItems('reviews', RESTAURANT_REVIEWS_ID_URL + restaurant.id, restaurant.id)\n            .then(reviews => {\n              // Fill restaurant reviews.\n              fillRestaurantReviewsHTML(reviews);\n            })\n            .catch(error => {\n              console.log(error);\n            });\n        }\n\n        /**\n         * Create restaurant operating hours HTML table and add it to the webpage.\n         */\n        function fillRestaurantHoursHTML(operatingHours) {\n          const hours = d.gEBI('restaurant-hours');\n          for (let key in operatingHours) {\n            const row = d.cE('tr'),\n                  day = d.cE('th'),\n                  time = d.cE('td');\n\n            day.innerHTML = key;\n            day.scope = 'row';\n\n            time.innerHTML = operatingHours[key];\n\n            row.append(day, time);\n\n            hours.appendChild(row);\n          }\n        }\n\n        /**\n         * Create all reviews HTML and add them to the webpage.\n         */\n        function fillRestaurantReviewsHTML(reviews) {\n          const container = d.gEBI('reviews-container'),\n                title = d.cE('h2'),\n                ul = d.gEBI('reviews-list');\n\n          title.innerHTML = 'Reviews';\n          container.insertBefore(title, container.firstChild);\n\n          if (!reviews) {\n            const noReviews = d.cE('p');\n            noReviews.innerHTML = n.online ? 'No reviews yet!' : 'Sorry, reviews for this restaurant are not available offline.';\n            container.insertBefore(noReviews, container.lastChild);\n            return;\n          }\n\n          reviews.reverse().forEach(review => {\n            ul.appendChild(createRestaurantReviewHTML(review));\n          });\n        }\n\n        /**\n         * Create review HTML and add it to the webpage.\n         */\n        function createRestaurantReviewHTML(review) {\n          const li = d.cE('li'),\n                article = d.cE('article'),\n                header = d.cE('header'),\n                heading = d.cE('h3'),\n                name = d.cE('span'),\n                ratingContainer = d.cE('p'),\n                rating = d.cE('abbr'),\n                comments = d.cE('p');\n\n          name.innerHTML = review.name;\n\n          if (review.updatedAt) {\n            const date = d.cE('time'),\n                  theDate = new Date(review.updatedAt),\n                  options = {\n                    year: 'numeric',\n                    month: 'long',\n                    day: 'numeric'\n                  };\n\n            date.dateTime = theDate.toISOString();\n            date.innerHTML = theDate.toLocaleDateString('en-US', options);\n            date.className = 'time';\n\n            heading.append(name, date);\n          } else { // HTML for new review.\n            const sending = d.cE('span');\n\n            sending.innerHTML = 'Review is sending…';\n            sending.className = 'time';\n\n            heading.append(name, sending);\n          }\n\n\n          header.appendChild(heading);\n\n          /* Ratings are often presented either as a set of images or characters, e.g. \"***\". For these, the <abbr> element is particularly useful, as such characters are an abbreviation for the precise rating, e.g. <abbr class=\"rating\" title=\"3.0\">***</abbr>. http://microformats.org/wiki/hreview */\n          /* Relying on the title attribute is currently discouraged as many user agents do not expose the attribute in an accessible manner as required by w3c specifications. https://www.w3.org/TR/html/dom.html#the-title-attribute */\n          /* The only very tiny exception a title attribute will be read by a screen reader is if there's absolutely no link anchor text. https://silktide.com/i-thought-title-text-improved-accessibility-i-was-wrong/ */\n          /* The title is an HTML global attribute, so it can be used on any HTML element. The screen readers behaviour is the same for all elements with the title attribute. For these reasons, in this case, the inner text node was left blank. The stars are rendered using ::before and ::after pseudo elements. --> */\n          rating.title = `Rating: ${review.rating} of 5`;\n          rating.className = `stars-${review.rating}`;\n          ratingContainer.appendChild(rating);\n\n          comments.innerHTML = review.comments;\n\n          article.append(header, ratingContainer, comments);\n\n          li.appendChild(article);\n\n          return li;\n        }\n      })();\n    }\n  })\n  .catch(error => {\n    console.log(error);\n  });\n\n// === DATABASE HELPER FUNCTIONS ===\n\n/**\n * Fetch all restaurants or reviews with proper error handling.\n */\nfunction fetchItems(itemsString, url, restaurantId) {\n  // Check if indexedDB is supported.\n  if (w.indexedDB) {\n    // Open a connection with indexedDB.\n    const request = w.indexedDB.open(`nyc_rr_data`, 1);\n\n    // Create the objects store.\n    request.onupgradeneeded = event => {\n      const db = event.target.result;\n\n      // Create the object store for restaurants.\n      db.createObjectStore('restaurants', {keyPath: 'id'});\n\n      // Create the object store for reviews with restaurant_id index.\n      db.createObjectStore('reviews', {keyPath: 'id'}).createIndex('restaurant_id', 'restaurant_id', {unique: false});\n    };\n\n    // The fetchItems function must return a Promise.\n    return new Promise(resolve => {\n\n      request.onsuccess = event => {\n        const db = event.target.result;\n        // Open a transaction and obtain a reference to the object store.\n        const store = db.transaction([itemsString], 'readonly').objectStore(itemsString);\n        const indexOrStore = (itemsString === 'reviews') ? store.index('restaurant_id') : store;\n\n        resolve(new Promise(resolve => {\n          // Use cursors to retrieve all objects in the object store and add them to an array.\n          let IDBItems = [];\n\n          const range = restaurantId ? IDBKeyRange.only(restaurantId) : null;\n          indexOrStore.openCursor(range).onsuccess = event => {\n            let cursor = event.target.result;\n            // Check if the object store is empty.\n            if (!cursor && !IDBItems.length) {\n              // Fetch from the network.\n              resolve(fetch(url)\n                .then(response => {\n                  if (!response.ok) {\n                    throw Error(`Request failed. Returned status of ${response.statusText}`);\n                  }\n                  return response.json();\n                })\n                .then(items => {\n                  // Open a transaction.\n                  const store = db.transaction([itemsString], 'readwrite').objectStore(itemsString);\n                  // Save data into the object store.\n                  items.forEach(item => {\n                    store.put(item);\n                  });\n                  return items;\n                })\n                .catch(error => {\n                  console.log(error);\n                }));\n            } else if (cursor) { // Check the cursor.\n              // Save cursor value in an array.\n              IDBItems.push(cursor.value);\n\n              if (n.onLine && cursor.value.offline_request) {\n                // Handle forgotten offline requests.\n                handleForgottenOfflineRequests(itemsString, cursor.value.id);\n              }\n\n              cursor.continue();\n            } else {\n              // Return all data from indexedDB.\n              resolve(IDBItems);\n            }\n          };\n          indexOrStore.openCursor(range).onerror = event => {\n            // Add a fallback.\n            console.log(event.target.error);\n            resolve(onlyFetchItems(itemsString, url));\n          };\n        }));\n      };\n      request.onerror = event=> {\n        /* IndexedDB storage in browsers' privacy modes only lasts in-memory until the incognito session is closed (Private Browsing mode for Firefox and Incognito mode for Chrome, but in Firefox this is not implemented yet as of Nov 2015 so you can't use IndexedDB in Firefox Private Browsing at all). https://bugzilla.mozilla.org/show_bug.cgi?id=781982 */\n        console.log(event.target.error);\n        resolve(onlyFetchItems(itemsString, url));\n      };\n    });\n  } else { // If indexedDB is not supported.\n    return onlyFetchItems(itemsString, url);\n  }\n}\n\n/**\n * Fetch all restaurants or reviews if indexedDB is not supported.\n */\nfunction onlyFetchItems(itemsString, url) {\n  return fetch(url)\n      .then(response => {\n        if (!response.ok) {\n          throw Error(`Request failed. Returned status of ${response.statusText}`);\n        }\n        return response.json();\n      })\n      .then(items => {\n        return items;\n      })\n      .catch(error => {\n        console.log(error);\n      });\n}\n\n/**\n * Handle forgotten offline requests after page reload.\n */\nfunction handleForgottenOfflineRequests(itemsString, id) {\n  // Exit if service worker or sync manager are unavailable.\n  if (!n.serviceWorker || !w.SyncManager) {\n    return;\n  }\n\n  /* Send a message to SW to handle forgotten offline requests for a restaurant. */\n  if (itemsString === 'restaurants') {\n    n.serviceWorker.controller.postMessage({\n      action: `favorite-sync-${id}`\n    });\n  } else if (itemsString === 'reviews') {\n    /* Send a message to SW to handle forgotten offline requests for a review. */\n    n.serviceWorker.controller.postMessage({\n      action: `review-sync-${id}`\n    });\n  }\n}\n\n/**\n * Set favorite with background sync implementation.\n */\nfunction setFavorite(data) {\n  // When offline register a background sync tag.\n  if (!n.onLine && n.serviceWorker && w.SyncManager && w.indexedDB) {\n    // Save data in indexedDB and add offline request flag.\n    saveFavoriteOnIndexedDB(data, true);\n    n.serviceWorker.ready\n      .then(sw => {\n        return sw.sync.register(`favorite-sync-${data.id}`);\n      })\n      .catch(error => {\n        console.log(error);\n        // Try to update database on network with fetch API.\n        updateFavoriteOnline(data);\n      });\n    return;\n  }\n\n  // Save data in indexedDB if it is supported.\n  if (w.indexedDB) {\n    saveFavoriteOnIndexedDB(data);\n  }\n\n  // Update database on network with fetch API.\n  updateFavoriteOnline(data);\n}\n\n/**\n * Function definition for updating database on network.\n */\nfunction updateFavoriteOnline(data) {\n  fetch(`${RESTAURANTS_URL}/${data.id}/?is_favorite=${data.is_favorite}`, {\n      method: 'PUT'\n    })\n    .catch(error => {\n      console.log(error);\n    });\n}\n\n/**\n * Save if the restaurant is favorite on idexedDB.\n */\nfunction saveFavoriteOnIndexedDB(data, offlineRequest) {\n  // Open a connection with indexedDB.\n  const request = w.indexedDB.open(`nyc_rr_data`, 1);\n\n  // Open a transaction and obtain a reference to the object store.\n  request.onsuccess = event => {\n    const db = event.target.result,\n          store = db.transaction(['restaurants'], 'readwrite').objectStore('restaurants'),\n          request = store.get(data.id); // Get data from indexedDB.\n\n    // Update data in indexedDB.\n    request.onsuccess = event => {\n      const idbData = event.target.result;\n      idbData.is_favorite = data.is_favorite;\n\n      if (offlineRequest) idbData.offline_request = true;\n\n      const request = store.put(idbData);\n\n      request.onerror = event => {\n        console.log(event.target.error);\n      };\n    };\n\n    request.onerror = event => {\n      console.log(event.target.error);\n    };\n  };\n\n  request.onerror = event => {\n    console.log(event.target.error);\n  };\n}\n\n/**\n * Add review with background sync implementation.\n */\nfunction addReview(data) {\n  // When offline register a background sync tag.\n  if (!n.onLine && n.serviceWorker && w.SyncManager && w.indexedDB) {\n    // Save data in indexedDB and add offline request flag.\n    return saveReviewOnIndexedDB(data, true)\n      .then(reviewId => {\n        n.serviceWorker.ready\n          .then(sw => {\n            return sw.sync.register(`review-sync-${reviewId}`);\n          })\n          .catch(error => {\n            console.log(error);\n          });\n      });\n  }\n\n  // Update database on network with fetch API.\n  updateReviewOnline(data);\n}\n\n/**\n * Save review on idexedDB, and return a promise with the review id.\n */\nfunction saveReviewOnIndexedDB(data, offlineRequest) {\n  return new Promise(resolve => {\n    // Open a connection with indexedDB.\n    const request = w.indexedDB.open(`nyc_rr_data`, 1);\n\n    // Open a transaction and obtain a reference to the object store.\n    request.onsuccess = event => {\n      const db = event.target.result,\n            store = db.transaction(['reviews'], 'readwrite').objectStore('reviews');\n\n      if (offlineRequest) data.offline_request = true;\n\n      // To save data on indexedDB the key path must to have a value.\n      data.id = data.id || `_${Math.random().toString(36).substr(2, 9)}`;\n\n      const request = store.put(data);\n\n      request.onsuccess = () => {\n        resolve(data.id);\n      };\n\n      request.onerror = event => {\n        console.log(event.target.error);\n      };\n    };\n\n    request.onerror = event => {\n      console.log(event.target.error);\n    };\n  });\n}\n\n/**\n * Function definition for updating database on network.\n */\nfunction updateReviewOnline(data) {\n  fetch(RESTAURANT_REVIEWS_URL, {\n      method: 'POST',\n      body: JSON.stringify(data),\n      headers: new Headers({\n        'Content-Type': 'application/json'\n      })\n    })\n    .then(() => {\n      if (w.indexedDB) {\n        fetch(`${RESTAURANT_REVIEWS_ID_URL}${data.restaurant_id}`)\n          .then(response => {\n            if (!response.ok) {\n              throw Error(`Request failed. Returned status of ${response.statusText}`);\n            }\n            return response.json();\n          })\n          .then(reviews => {\n            // Save data into the object store.\n            reviews.forEach(review => {\n              saveReviewOnIndexedDB(review);\n            });\n          });\n      }\n    })\n    .catch(error => {\n      console.log(error);\n    });\n}\n\n/**\n * Map marker for a restaurant.\n */\nfunction mapMarkerForRestaurant(restaurant, map) {\n  const marker = new google.maps.Marker({\n    position: restaurant.latlng,\n    title: `${restaurant.name} ${restaurant.neighborhood}`,\n    url: urlForRestaurant(restaurant),\n    map: map,\n    animation: google.maps.Animation.DROP\n  });\n  return marker;\n}\n\n/**\n * Return restaurant page URL.\n */\nfunction urlForRestaurant(restaurant) {\n  return (`/restaurant.html?id=${restaurant.id}`);\n}\n\n/**\n * Return restaurant image URL.\n */\nfunction imageUrlForRestaurant(restaurant, width) {\n  return `/img/${restaurant.photograph}-${width}w.jpg`;\n}\n\n/**\n * Return restaurant image srcset.\n */\nfunction formatSrcset(restaurant) {\n  let srcsetStr = [];\n  for (let w = 3; w < 9; w++) {\n    srcsetStr.push(`${imageUrlForRestaurant(restaurant, w*100)} ${w*100}w`);\n  }\n  return srcsetStr.join(', ');\n}\n\n// === COMMON FUNCTIONS ===\n\nfunction addAsyncScript(src) {\n  const script = d.cE('script');\n  script.src = src;\n  script.setAttribute('async', '');\n  d.head.appendChild(script);\n}\n\n/**\n * Initialize Google Maps static API.\n */\nfunction initStaticMap(callback) {\n  let doit = setTimeout(callback);\n\n  // Reboot Google Maps static API on window resize end.\n  w.addEventListener('resize', () => {\n    clearTimeout(doit);\n    doit = setTimeout(callback, 60);\n  });\n}\n\n/**\n * Get parameters to make responsive the free Google Maps static API.\n */\nfunction getResponsiveStaticMapParameters() {\n  let width = staticMap.clientWidth,\n      height = staticMap.clientHeight;\n\n  /* The free Google Maps static API returns 640x640 maximum image resolution, and 1280x1280 with scale 2. */\n  const scale = width > 640 || height > 640 ? 2 : 1,\n  aspectRatio = width > height ? +(width/height).toFixed(6) : +(height/width).toFixed(6);\n  if (width > height) {\n    width = width > 640 ? 640 : width;\n    height = Math.round(width/aspectRatio);\n  } else {\n    height = height > 640 ? 640 : height;\n    width = Math.round(height/aspectRatio);\n  }\n\n  return {\n    width,\n    height,\n    scale\n  };\n}\n\n/**\n * Asyncronous fetching Google Maps static API with lazy loading.\n */\nfunction lazyLoadStaticMap(url) {\n  fetch(url)\n    .then(response => response.blob())\n      .then(images => {\n        staticMap.style.backgroundImage = `url(${URL.createObjectURL(images)})`;\n        staticMap.style.opacity = 1;\n      })\n      .catch(error => {\n        console.log(error);\n      });\n}\n\n/**\n * Add event listeners to static map for loading dynamic map API.\n */\nfunction addListenerToStaticMap() {\n  staticMap.style.cursor = 'pointer';\n\n  addListenerTo(staticMap, () => {\n    actionOnMap();\n  }, true);\n}\n\n/**\n * Add listeners to an element for tracking click and keydown events.\n */\nfunction addListenerTo(element, callback, remove) {\n  // Function fire on click event.\n  const doit = (event) => {\n    event.preventDefault();\n    event.stopPropagation();\n    callback();\n    if (remove) removeListeners();\n  };\n\n  // Function fire on keydown event.\n  const f = event => {\n    if (event.keyCode === 13) {\n      doit(event, true);\n    }\n  };\n\n  // Add both event listeners.\n  element.addEventListener('click', doit);\n  element.addEventListener('keydown', f);\n\n  // Remove both event listeners.\n  function removeListeners() {\n    element.removeEventListener('click', doit);\n    element.removeEventListener('keydown', f);\n  }\n}\n\n/**\n * Do what you have to do on map.\n */\nfunction actionOnMap() {\n  if (!n.onLine) { // Check if offline.\n    showOfflineAlert('x');\n  } else {\n    loadMap();\n    swapMap();\n  }\n}\n\n/**\n * Show an alert to inform map is not available offline.\n */\nfunction showOfflineAlert(button) {\n  const offlineAlert = d.cE('div'),\n        paragraphAlert = d.cE('p');\n\n  offlineAlert.id = 'offline-alert';\n  offlineAlert.setAttribute('role', 'alert');\n  paragraphAlert.innerHTML = '⚠ You are offline, map is not available.';\n  offlineAlert.appendChild(paragraphAlert);\n\n  if (button) { // Add close button if requested.\n    const p = d.cE('p'),\n          close = d.cE('button');\n\n    close.type = 'button';\n    close.innerHTML = 'CLOSE';\n    p.appendChild(close);\n    offlineAlert.appendChild(p);\n\n    addListenerTo(close, () => {\n      offlineAlert.remove();\n      staticMap.removeAttribute('class');\n      addListenerToStaticMap();\n    });\n  }\n\n  staticMap.className = 'offline';\n  staticMap.style.opacity = 1;\n  staticMap.appendChild(offlineAlert);\n  staticMap.style.cursor = 'default';\n}\n\n/**\n * Load dynamic map API asynchronously from HTML.\n */\nfunction loadMap() {\n  addAsyncScript('https://maps.googleapis.com/maps/api/js?key=AIzaSyAxfOOcB40yMKfupF4qyfa4hwvhTclZboA&libraries=places&callback=initMap');\n}\n\nfunction swapMap() {\n  d.gEBI('map').style.display = 'block';\n  staticMap.removeAttribute('tabindex');\n  staticMap.removeAttribute('role');\n  staticMap.removeAttribute('aria-label');\n}\n\n/**\n * Add click listener to marker.\n */\nfunction addClickListenerToMarker(marker) {\n  marker.addListener('click', () => {\n    w.location.href = marker.url;\n  });\n}\n\nfunction initMapA11y(callback, isIndex) {\n  // Create an overlay object for assign an id to markerLayer.\n  const overlay = new google.maps.OverlayView();\n  overlay.draw = function () {\n    this.getPanes().markerLayer.id='markerLayer';\n  };\n  overlay.setMap(map);\n\n  if (!tilesLoaded) {\n    // This event fires when the visible tiles have finished loading.\n    const listenerTiles = map.addListener('tilesloaded', () => {\n      callback();\n      addA11yToMap(isIndex);\n      tilesLoaded = true;\n      if (!mapOnFilter) d.querySelector('#map div[tabindex=\"0\"]').focus();\n      google.maps.event.removeListener(listenerTiles);\n    });\n  } else {\n    callback();\n  }\n}\n\n/**\n * Make markers focusable.\n */\nfunction addA11yToMarkers(restaurant, currentRestaurants, callback) {\n  setTimeout(() => {\n    // Markers are coded with area tags.\n    const areas = d.querySelectorAll('[id^=\"gmimap\"]> area'),\n    /* Seems impossible to style marker directly, but to any marker corresponds an img tag and the order is the same. */\n          layers = d.querySelectorAll('#markerLayer img');\n\n    for (let i = 0; i < areas.length; i++) {\n      areas[i].tabIndex = 0;\n      areas[i].addEventListener('focus', () => {\n        layers[i].classList.add('focused');\n      });\n      areas[i].addEventListener('blur', () => {\n        layers[i].classList.remove('focused');\n      });\n\n      // Google Maps allows only click event on markers.\n      areas[i].addEventListener('keydown', (event) => {\n        if (event.keyCode === 13) {\n          restaurant = restaurant || currentRestaurants[i];\n          w.location.href = urlForRestaurant(restaurant);\n        }\n      });\n    }\n    callback();\n  }, 150);\n}\n\n/**\n * Fix some accessibility issues with Google Maps API.\n */\nfunction addA11yToMap(isIndex) {\n  const skipMap = d.cE('a'),\n        mapLabel = d.cE('h2'),\n        divWithTabindex = d.querySelector('#map div[tabindex=\"0\"]'),\n        mapDOMElement = d.gEBI('map');\n\n  // Add a skip map link.\n  skipMap.className = 'skip-link button';\n  skipMap.href = isIndex ? '#filter-options' : '#restaurant-container';\n  skipMap.innerHTML = 'Skip the map';\n  staticMap.insertBefore(skipMap, staticMap.firstChild);\n\n  // Add a map label.\n  mapLabel.id = 'map-label';\n  mapLabel.className = 'sr-only';\n  mapLabel.innerHTML = 'Google Maps Widget: shows restaurants location';\n  staticMap.insertBefore(mapLabel, staticMap.firstChild);\n\n  // Add aria-lebelledBy to the div focusable with tab.\n  divWithTabindex.setAttribute('aria-labelledby', 'map-label');\n\n  // Highlight when map DOM element is onfocus.\n  divWithTabindex.addEventListener('focus', () => {\n    mapDOMElement.classList.add('focused');\n  });\n\n  // Remove highlight when map DOM element is onblur.\n  divWithTabindex.addEventListener('blur', () => {\n    mapDOMElement.classList.remove('focused');\n  });\n\n  /* Enable Google Maps keyboard UI, when map DOM element or any of his children is onfocus. */\n  mapDOMElement.addEventListener('focus', () => {\n    map.setOptions({keyboardShortcuts: true});\n  }, true);\n\n  /* Disable Google Maps keyboard UI, when map DOM element or any of his children is onblur. */\n  mapDOMElement.addEventListener('blur', () => {\n    map.setOptions({keyboardShortcuts: false});\n  }, true);\n}\n\n/**\n * Add restaurant image HTML.\n */\nfunction addImageOfTo(restaurant, parent, isIndex) {\n  const image = d.cE('img');\n  image.className = 'restaurant-img';\n\n  /* Adding alternative text for images is the first principle of web accessibility. [...] Every image must have an alt attribute. This is a requirement of HTML standard (with perhaps a few exceptions in HTML5). Images without an alt attribute are likely inaccessible. In some cases, images may be given an empty or null alt attribute (e.g., alt=\"\"). https://webaim.org/techniques/alttext/ */\n  image.alt = restaurant.photoDescription || (isIndex ? `The ${restaurant.cuisine_type} Restaurant ${restaurant.name}` : `The Restaurant ${restaurant.name} in ${restaurant.neighborhood}`);\n\n  // Add just a transparent space with right ratio as placeholder.\n  image.src = 'data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"8\" height=\"6\"></svg>';\n\n  if (!restaurant.photograph) { // Check if there is not a photo.\n    image.src = '/img/image-fallback.svg';\n    parent.insertBefore(image, parent.firstChild);\n  } else {\n    const picture = d.cE('picture'),\n          jpg = d.cE('source'),\n          webp = d.cE('source');\n\n    jpg.dataset.srcset = formatSrcset(restaurant);\n    webp.dataset.srcset = jpg.dataset.srcset.replace(/w.jpg/g, 'w.webp');\n\n    jpg.sizes = `(min-width: 1366px) calc((1366px - ${isIndex ? '5rem) / 4' : '4rem) / 3'}), (min-width: 1080px) calc((100vw - 4rem) / 3), (min-width: 700px) calc((100vw - 3rem) / 2), calc(100vw - 2rem)`;\n    webp.sizes = jpg.sizes;\n\n\n    image.dataset.src = imageUrlForRestaurant(restaurant, 800);\n    image.classList.add('lazy');\n\n    // Remove source tag for webp images if they are not supported.\n    image.onerror = () => {webp.remove();};\n\n    picture.append(webp, jpg, image);\n\n    parent.insertBefore(picture, parent.firstChild);\n  }\n}\n\n/**\n * Lazy load images of restaurants.\n */\nfunction lazyLoad() {\n  const lazyImages = [].slice.call(d.querySelectorAll('.lazy'));\n\n  if (!lazyImages) return; // Exit from function if there are not .lazy images.\n\n  let observer = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) { // Check if the image is visible.\n        const image = entry.target,\n              webp = image.parentElement.children[0],\n              jpg = image.parentElement.children[1];\n\n        webp.srcset = webp.dataset.srcset;\n        jpg.srcset = jpg.dataset.srcset;\n        image.src = image.dataset.src;\n\n        // Make the image visible.\n        image.style.opacity = 1;\n\n        webp.removeAttribute('data-srcset');\n        jpg.removeAttribute('data-srcset');\n        image.removeAttribute('data-src');\n\n        // Remove observer from image.\n        observer.unobserve(image);\n      }\n    });\n  });\n\n  // Attach observer to images.\n  lazyImages.forEach(image => {\n    observer.observe(image);\n  });\n}\n})(window, document, navigator);\n"]}