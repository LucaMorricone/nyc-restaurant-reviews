{"version":3,"sources":["sw.js"],"names":["s","ORIGIN","STATIC_CACHE","DYNAMIC_CACHE","CORS_DYNAMIC_CACHE","RESOURCES_TO_CACHE","addEventListener","event","sendMessageToClients","message","clients","matchAll","then","forEach","client","postMessage","action","catch","error","console","log","waitUntil","Promise","all","cacheNames","cacheName","map","caches","keys","filter","startsWith","request","indexOf","claim","response","url","location","origin","match","respondWith","cache","fetch","mode","data","put","clone","skipWaiting","self"],"mappings":"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","file":"sw.js","sourcesContent":["((s) => {\n  'use strict';\n  const SW_VERSION = 1,\n    ORIGIN = 'NYC-RR-',\n    STATIC_CACHE = `${ORIGIN}static-cache-v${SW_VERSION}`,\n    DYNAMIC_CACHE = `${ORIGIN}dynamic-cache-v${SW_VERSION}`,\n    CORS_DYNAMIC_CACHE = `${ORIGIN}cors-dynamic-cache-v${SW_VERSION}`,\n    RESOURCES_TO_CACHE = [\n      '/',\n      '/index.html',\n      '/restaurant.html',\n      '/css/styles.css',\n      '/js/main.js',\n      '/js/dbhelper.js',\n      '/js/index.js',\n      '/js/restaurant_info.js',\n      '/img/image-placeholder.svg',\n      '/404.html',\n      '/offline.html',\n      /* Unfortunally Service Worker 'fetch' event does not trigger for favicons in Chrome. This bug is still open. https://bugs.chromium.org/p/chromium/issues/detail?id=448427 */\n      '/favicon.ico'\n  ];\n\n  /**\n   * Cache the main assets while installing SW.\n   */\n  s.addEventListener('install', event => {\n    event.waitUntil(\n      caches.open(STATIC_CACHE)\n        .then(cache => {\n          return cache.addAll(RESOURCES_TO_CACHE);\n        })\n        .catch(error => {\n          console.log('[SW] Installation failed, error:', error);\n        })\n    );\n  });\n\n  /**\n   * Remove outdated caches while a new SW is activating.\n   */\n  s.addEventListener('activate', event => {\n    event.waitUntil(\n      caches.keys()\n        .then(cacheNames => {\n          return Promise.all(\n            cacheNames.filter(cacheName => {\n              // Caches are shared across the whole origin.\n              return (cacheName.startsWith(ORIGIN) && cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE);\n            }).map(cacheName => {\n              return caches.delete(cacheName);\n            })\n          );\n        })\n        .then(() => {\n          /* Allow the active service worker to set itself as the controller for all clients within its scope. This triggers a \"controllerchange\" event on navigator.serviceWorker in any clients that become controlled by this service worker. https://developer.mozilla.org/en-US/docs/Web/API/Clients/claim */\n          return s.clients.claim();\n        })\n        .catch(error => {\n          console.log('[SW] Activation failed, error:', error);\n        })\n    );\n  });\n\n  /**\n   * Cache other resources dynamically with a fallback to the network.\n   */\n  s.addEventListener('fetch', event => {\n    /* The fetch handler serves responses only for same-origin resources. */\n    if (event.request.url.startsWith(s.location.origin)) {\n      if (event.request.url.indexOf('restaurant.html') > -1) {\n        if (event.request.url.search(/id=./) === -1) {\n          event.respondWith(\n            caches.match('/404.html')\n          );\n          return;\n        }\n        event.respondWith(\n          caches.match('/restaurant.html')\n        );\n      } else {\n        event.respondWith(\n          caches.match(event.request)\n            .then(response => {\n              if (response) return response;\n              return caches.open(DYNAMIC_CACHE)\n                .then(cache => {\n                  return fetch(event.request)\n                    .then(response => {\n                      if (response.status === 404) {\n                        return caches.match('/404.html');\n                      }\n                      cache.put(event.request, response.clone())\n                        .catch(error => {\n                          /* In some cases dynamic caching fails: e.g. it's not possible to cache a resource because a \"DOMException: Quota exceeded\" error fires. */\n                          console.log('[SW] Dynamic caching failed, error', error, event.request.url);\n                        });\n                      return response;\n                    })\n                    .catch(error => {\n                      console.log('[SW] Fetch request failed, error', error);\n                      return caches.match('/offline.html');\n                    });\n                })\n                .catch(error => {\n                  console.log('[SW] Opening dynamic cache failed, error', error);\n                });\n            })\n            .catch(error => {\n              console.log('[SW] Something failed while matching a request, error', error);\n            })\n        );\n      }\n    } else if (event.request.url.startsWith('https://maps.googleapis.com/maps/api/staticmap')) {\n      event.respondWith(\n        caches.match(event.request).then((response) => {\n          if (response) return response;\n          /* Opening Devtools triggers \"only-if-cached\" request which cannot be handled by Service Worker. https://bugs.chromium.org/p/chromium/issues/detail?id=823392 */\n          /* This is a workaround: https://github.com/paulirish/caltrainschedule.io/pull/51/commits/82d03d9c4468681421321db571d978d6adea45a7 */\n          if (event.request.cache === 'only-if-cached' && event.request.mode !== 'same-origin') {\n            return; // Skip the request.\n          }\n          return caches.open(CORS_DYNAMIC_CACHE).then((cache) => {\n            return fetch(event.request).then((response) => {\n              cache.put(event.request, response.clone())\n                .catch((error) => {\n                  /* In some cases dynamic caching fails: e.g. it's not possible to cache a resource because a \"DOMException: Quota exceeded\" error fires. Resources called through the 'chrome-extension' protocol produce annoying errors too. */\n                  if (event.request.mode === 'no-cors' || event.request.url.startsWith('chrome-extension')) {\n                    console.log('[SW] Dynamic caching failed, skipped error', error, event.request.url);\n                    return; // Skip the error.\n                  }\n                  caches.delete(CORS_DYNAMIC_CACHE); // Clear the cache.\n                  console.log('[SW] Dynamic caching failed, error', error, event.request.url, 'The cache is cleared with CORS resources.');\n                });\n              return response;\n            });\n          });\n        })\n      );\n    }\n  });\n\n  /**\n   * Listen messages from client.\n   */\n  s.addEventListener('message', function(event) {\n    if (event.data.action === 'refresh') {\n      event.waitUntil(\n        s.skipWaiting() // Activate a new SW that is waiting.\n          .then(() => {\n            /* After receiving a message from one client, the new SW turns the message to all clients. */\n            sendMessageToClients('refreshed');\n          })\n          .catch(error => {\n            console.log('[SW] Something failed while skipping wait, error', error);\n          })\n      );\n    }\n    if (event.data.action === 'dismiss') {\n      event.waitUntil(\n        /* After receiving a message from one client, the current SW turns the message to all clients. */\n        sendMessageToClients('dismissed')\n      );\n    }\n  });\n\n  /**\n   * Send a message to all clients.\n   */\n  function sendMessageToClients(message) {\n    /* Get a list of SW Client objects, and send a message to everyone. */\n    s.clients.matchAll()\n      .then(clients => {\n        clients.forEach(client => {\n          client.postMessage({action: message});\n        });\n      })\n      .catch(error => {\n        console.log('[SW] Something failed while sending message to clients, error', error);\n      });\n  }\n})(self);"]}